<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Philbert</title>
    <link>https://ziwon.github.io/</link>
    <description>Recent content on Philbert</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>This work is licensed under a Creative Commons Attribution-ShareAlike 4.0 International License.</copyright>
    <lastBuildDate>Fri, 09 Dec 2016 11:00:25 +0900</lastBuildDate>
    <atom:link href="https://ziwon.github.io/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Using custom model_to_dict() in Django</title>
      <link>https://ziwon.github.io/posts/using_custom_model_to_dict_in_django/</link>
      <pubDate>Fri, 09 Dec 2016 11:00:25 +0900</pubDate>
      
      <guid>https://ziwon.github.io/posts/using_custom_model_to_dict_in_django/</guid>
      <description>&lt;p&gt;In Django, when converting a database model to a dictionary, I usually used to convert only the member variables corresponding to the column of the table to handle the response to the request in the form of Json and so on. But, whenever you encounter a member variable of type &lt;code&gt;ManyToManyField&lt;/code&gt;, it would be too cumbersome to write three or four lines of code each time to loop around to get their values from the member variables of the &lt;code&gt;ManyToManyField&lt;/code&gt; in a model object.&lt;/p&gt;

&lt;p&gt;For example, suppose you have a modeling class of &lt;code&gt;Publication&lt;/code&gt;, &lt;code&gt;Article&lt;/code&gt; as follows.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;from django.db import models

class Publication(models.Model):
    title = models.CharField(max_length=30)

    def __str__(self):
        return self.title

    class Meta:
        ordering = (&#39;title&#39;,)

class Article(models.Model):
    headline = models.CharField(max_length=100)
    publications = models.ManyToManyField(Publication)

    def __str__(self):
        return self.headline

    class Meta:
        ordering = (&#39;headline&#39;,)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;For the &lt;code&gt;Publication&lt;/code&gt; instance, you can convert it to a dictionary by calling the &lt;code&gt;model_to_dict()&lt;/code&gt; function only once. However, when converting an instance of &lt;code&gt;Article&lt;/code&gt; with a member variable of &lt;code&gt;ManyToManyField&lt;/code&gt; to a dictionary, you have to invoke &lt;code&gt;model_to_dict()&lt;/code&gt; or loop around more than once to get their values because &lt;code&gt;ManyToManyField&lt;/code&gt; is a list type.&lt;/p&gt;

&lt;p&gt;Whenever I encountered &lt;code&gt;ManyToManyField&lt;/code&gt;, I used to create a separate method, or loop it, and convert it each by each. Suddenly, every time I write a for statement or a separate function, I thought it would be better to solve it all once.&lt;/p&gt;

&lt;p&gt;For example, let&amp;rsquo;s say you have a property in the &lt;code&gt;Article&lt;/code&gt; class, a member function, and several &lt;code&gt;ManyToManyField&lt;/code&gt;s like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class Article(models.Model):
    headline = models.CharField(max_length=100)
    publications = models.ManyToManyField(Publication)
    tags = models.ManyToManyField(Tag)

    def convert_cover_img(self):
        ...

    @property
    def count(self):
        ...

    def __str__(self):
        return self.headline

    class Meta:
        ordering = (&#39;headline&#39;,)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;What I want is to specify each values to be transformed, it could be such as member variables, member functions, and properties of the modeling class, as shown below, and the whole instance is converted into a single dictationary chunk in a single call. For example, if you need only one of the member variables of &lt;code&gt;ManyToManyField&lt;/code&gt;, you can convert it to &lt;code&gt;__[field_name]&lt;/code&gt; by specifying the desired field name as follows.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;FIELDS = {&#39;id&#39;, &#39;headline&#39;, &#39;publications__title&#39;, &#39;tags__name&#39;, &#39;convert_cover_img&#39;, &#39;count&#39;]
result = OrderedDict()
result[&#39;data&#39;] = [model_to_dict(instance=obj, fields=FIELDS) for obj in page.object_list]
result[&#39;has_next&#39;] = page.has_next()
...
return JsonResponse(format_response(result, RES_OK))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Unfortunately, if you need more than one column for &lt;code&gt;ManyToManyField&lt;/code&gt; to build the response like json form, you have no choice but to define a seperate property or function in a model class. In a specific case, for example, if you are extending all attributes - like id, name and etc - of the tags member variable ManyToManyField while converting the Article instance.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@property
def tags_to_dict(self):
    ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;However, since the model class describes the process of transforming their member variables, the above manner has the advantage that it is well modularized and reusable. As a result, the entire code is really simple and neat, because it can hide the process of converting an instance to a dictionary.&lt;/p&gt;

&lt;p&gt;Now we no longer have to loop around to handle &lt;code&gt;ManyToManyFields&lt;/code&gt; or write a separate function. It also eliminates the need to worry about member properties or member functions, which is not modeling fields .&lt;/p&gt;

&lt;p&gt;Here is the code for &lt;code&gt;model_to_dict()&lt;/code&gt; that was created. Once the conversion code of the a model is unified into just one line as shown below, repetitive and annoying coding for conversion is no longer needed. Since the parent class is created and the most job in the inherited child class is just to specify only the fields to be converted. As a result, the development speed can be much faster, which can improve the quality of the query set manager or focus on more creative work.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;def model_to_dict(instance, fields=None, exclude=None, date_to_strf=None):
    from django.db.models.fields.related import ManyToManyField
    from django.db.models.fields import DateTimeField
    from django.db.models.fields.files import ImageField, FileField
    opts = instance._meta
    data = {}

    &amp;quot;&amp;quot;&amp;quot;
    Why is `__fields` in here?
        it holds the list of fields except for the one ends with a suffix &#39;__[field_name]&#39;.
        When converting a model object to a dictionary using this method,
        You can use a suffix to point to the field of ManyToManyField in the model instance.
        The suffix ends with &#39;__[field_name]&#39; like &#39;publications__name&#39;
    &amp;quot;&amp;quot;&amp;quot;
    __fields = list(map(lambda a: a.split(&#39;__&#39;)[0], fields or []))

    for f in chain(opts.concrete_fields, opts.virtual_fields, opts.many_to_many):
        is_edtiable = getattr(f, &#39;editable&#39;, False)

        if fields and f.name not in __fields:
            continue

        if exclude and f.name in exclude:
            continue

        if isinstance(f, ManyToManyField):
            if instance.pk is None:
                data[f.name] = []
            else:
                qs = f.value_from_object(instance)
                if qs._result_cache is not None:
                    data[f.name] = [item.pk for item in qs]
                else:
                    try:
                        m2m_field  = list(filter(lambda a: f.name in a and a.find(&#39;__&#39;) != -1, fields))[0]
                        key = m2m_field[len(f.name) + 2:]
                        data[f.name] = list(qs.values_list(key, flat=True))
                    except IndexError:
                        data[f.name] = list(qs.values_list(&#39;pk&#39;, flat=True))

        elif isinstance(f, DateTimeField):
            date = f.value_from_object(instance)
            data[f.name] = date_to_strf(date) if date_to_strf else date_to_timestamp(date)

        elif isinstance(f, ImageField):
            image = f.value_from_object(instance)
            data[f.name] = image.url if image else None

        elif isinstance(f, FileField):
            file = f.value_from_object(instance)
            data[f.name] = file.url if file  else None

        elif is_edtiable:
            data[f.name] = f.value_from_object(instance)

    &amp;quot;&amp;quot;&amp;quot;
    Just call an instance&#39;s function or property from a string with the function name in `__fields` arguments.
    &amp;quot;&amp;quot;&amp;quot;
    funcs = set(__fields) - set(list(data.keys()))
    for func in funcs:
        obj = getattr(instance, func)
        if inspect.ismethod(obj):
            data[func] = obj()
        else:
            data[func] = obj
    return data
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You might have performance problems, but if you have a lot of cost to convert an instance, you might be able to run 10 simultaneously using a coroutine, etc. Of course, if the order is important, when you collect the results, there may be a hassle, such as having to rearrange them in order.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>[번역] Effective Go: Concurrency</title>
      <link>https://ziwon.github.io/posts/effective-go-concurrency/</link>
      <pubDate>Fri, 25 Sep 2015 11:01:21 +0900</pubDate>
      
      <guid>https://ziwon.github.io/posts/effective-go-concurrency/</guid>
      <description>

&lt;blockquote&gt;
&lt;p&gt;2016.10.04 - &lt;a href=&#34;https://golang.org/doc/effective_go.html#concurrency&#34;&gt;Effective Go&lt;/a&gt;의 &lt;a href=&#34;https://gosudaweb.gitbooks.io/effective-go-in-korean/content/&#34;&gt;한글화&lt;/a&gt; 작업이완료되었습니다. 아래 동시성 번역 역시 번역팀의 도움으로 갱신되었습니다.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://golang.org/doc/effective_go.html#concurrency&#34;&gt;Effective Go&lt;/a&gt; 의 &lt;a href=&#34;https://web.archive.org/web/20160115102611/https://code.google.com/p/golang-korea/wiki/EffectiveGo?can=1#동시성(Concurrency)&#34;&gt;한글화 문서&lt;/a&gt;를 보던 중, Concurrency에 대한 부분이 빠져 있어서 해당 부분만 따로 번역했습니다. 원문의 출처는 &lt;a href=&#34;https://golang.org/doc/effective_go.html#concurrency&#34;&gt;여기&lt;/a&gt;입니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;통신에-의한-공유-share-by-communicating&#34;&gt;통신에 의한 공유 (Share by communicating)&lt;/h2&gt;

&lt;p&gt;동시성 프로그래밍은 광범위한 주제이므로 여기에서는 Go에 한정된 중요한 것들에 대해서만 지면을 할애한다.&lt;/p&gt;

&lt;p&gt;다양한 환경에서 동시성 프로그래은 공유 변수에 대한 정확한 접근을 구현하기 위해 엄수해야 하는 세세한 내용들로 어려워졌다. Go는 공유 변수가 채널을 돌려가며 전달된다는 점에서 다른 접근을 권장한다. 그리고 사실 공유 변수는 개별 쓰레드 실행에 의해서 결코 공유되지 않는다. 언제든지 하나의 고루틴이 값에 접근한다. 데이터 경쟁은 구현 설계상 발생할 수 없다. 이러한 사고방식을 권장하기 위해 이를 한 슬로건으로 줄였다:&lt;/p&gt;

&lt;p&gt;공유 메모리로 통신하지 말라. 대신, 통신으로 메모리를 공유하라.&lt;/p&gt;

&lt;p&gt;이런 접근은 너무 지나친 것일 수 있다. 예를 들어, 정수형 변수 주위에 뮤텍스를 두는 방식의 레퍼런스 카운트가 최고일지도 모른다. 그러나 상위 레벨에서 접근하는 방법으로써, 접근을 제어하는 채널을 사용하면 분명하고 정확한 프로그램을 보다 쉽게 작성할 수 있다.&lt;/p&gt;

&lt;p&gt;이 모델에 대해 생각해보는 한가지 방법은 단일 CPU에서 실행되는 전형적인 단일 쓰레드 프로그램을 떠올려 보는 것이다. 여기에는 동기화를 위한 기본 자료형이 필요 없다. 지금 또다른 그 인스턴스를 실행시켜 보라. 그러나 역시 동기화가 필요하지 않다. 이제 그 두 개를 통신하게 하는데, 그 통신 자체가 동기화 장치(synchronizer)인 경우, 여전히 다른 동기화가 필요 없다. 예를 들어, 유닉스 파이프 라인은 이 모델에 완벽하게 들어 맞는다. 동시성에 대한 Go의 접근 방식이 호어(Hoare)의 통신 순차적 프로세스 (CSP, Communicating Sequential Processes)에서 비롯되었지만, 타입 안전이 보장되는 식의 일반화된 유닉스 파이프라고 볼 수 있다.&lt;/p&gt;

&lt;h2 id=&#34;고루틴-goroutines&#34;&gt;고루틴 (Goroutines)&lt;/h2&gt;

&lt;p&gt;쓰레드, 코루틴, 프로세스 등 기존의 용어는 부정확한 함의를 전달하기 때문에 고루틴이라고 부른다. 고루틴은 단순한 모델이다. 즉, 같은 주소 공간에서 다른 고루틴과 동시에 실행되는 함수이다. 고루틴은 가볍다. 스택 영역을 할당하는 것에 비해 비용이 적게 든다. 그리고 그 스택은 작은 크기로 시작된다. 그래서 저렴하다. 그리고 필요한만큼 힙 스토리지를 할당(또는 해제)하여 커진다.&lt;/p&gt;

&lt;p&gt;고루틴은 OS의 다중 쓰레드에 멀티플렉싱되는데, I/O 작업을 위해 대기중일 때와 같이 하나의 고루틴이 블락이 되면 다른 고루틴이 계속 실행된다. 이런 설계는 쓰레드의 복잡한 생성과 관리에 대해 굳이 알 필요가 없게 해준다.&lt;/p&gt;

&lt;p&gt;새 고루틴을 호출하여 실행하려면 &lt;code&gt;go&lt;/code&gt; 키워드를 함수 또는 메쏘드 호출 앞에 둔다. 호출이 완료되면, 고루틴은 자동으로 종료된다. (백그라운드에서 명령을 실행하는 유닉스쉘 및 표기법과 유사한 효과이다.)&lt;/p&gt;

&lt;div class=&#34;highlight&#34; style=&#34;background: #202020&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span style=&#34;color: #6ab825; font-weight: bold&#34;&gt;go&lt;/span&gt; &lt;span style=&#34;color: #d0d0d0&#34;&gt;list.Sort()&lt;/span&gt;  &lt;span style=&#34;color: #999999; font-style: italic&#34;&gt;// list.Sort를 (정렬이 완료될 때까지) 기다리지 말고 동시에 실행&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;함수 리터럴은 고루틴 호출에 유용할 수 있다.&lt;/p&gt;

&lt;div class=&#34;highlight&#34; style=&#34;background: #202020&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span style=&#34;color: #6ab825; font-weight: bold&#34;&gt;func&lt;/span&gt; &lt;span style=&#34;color: #d0d0d0&#34;&gt;Announce(message&lt;/span&gt; &lt;span style=&#34;color: #6ab825; font-weight: bold&#34;&gt;string&lt;/span&gt;&lt;span style=&#34;color: #d0d0d0&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color: #d0d0d0&#34;&gt;delay&lt;/span&gt; &lt;span style=&#34;color: #d0d0d0&#34;&gt;time.Duration)&lt;/span&gt; &lt;span style=&#34;color: #d0d0d0&#34;&gt;{&lt;/span&gt;
    &lt;span style=&#34;color: #6ab825; font-weight: bold&#34;&gt;go&lt;/span&gt; &lt;span style=&#34;color: #6ab825; font-weight: bold&#34;&gt;func&lt;/span&gt;&lt;span style=&#34;color: #d0d0d0&#34;&gt;()&lt;/span&gt; &lt;span style=&#34;color: #d0d0d0&#34;&gt;{&lt;/span&gt;
        &lt;span style=&#34;color: #d0d0d0&#34;&gt;time.Sleep(delay)&lt;/span&gt;
        &lt;span style=&#34;color: #d0d0d0&#34;&gt;fmt.Println(message)&lt;/span&gt;
    &lt;span style=&#34;color: #d0d0d0&#34;&gt;}()&lt;/span&gt;  &lt;span style=&#34;color: #999999; font-style: italic&#34;&gt;//괄호 주목 - 반드시 함수를 호출해야 함&lt;/span&gt;
&lt;span style=&#34;color: #d0d0d0&#34;&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Go에서 함수 리터럴은 클로저이다. 즉, 함수가 참조하는 변수를 사용하는 동안에는 그 생존을 보장하는 방식으로 구현되어 있다는 것이다.&lt;/p&gt;

&lt;p&gt;위의 예제는 함수가 종료를 알릴 방법이 없기 때문에 아주 실용적이진 않다. 이를 위해 채널이 필요하다.&lt;/p&gt;

&lt;h2 id=&#34;채널-channels&#34;&gt;채널 (Channels)&lt;/h2&gt;

&lt;p&gt;맵과 마찬가지로, 채널은 &lt;code&gt;make&lt;/code&gt;로 할당되고, 그 결과 값은 실제 데이터 구조에 대한 참조로서 동작한다. 선택적인 정수형 매개변수가 주어지면, 채널에 대한 버퍼 크기가 설정된다. 이 값은 언버퍼드(Unbuffered) 또는 동기 채널에 대해서 기본값이 0이다.&lt;/p&gt;

&lt;div class=&#34;highlight&#34; style=&#34;background: #202020&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span style=&#34;color: #d0d0d0&#34;&gt;ci&lt;/span&gt; &lt;span style=&#34;color: #d0d0d0&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color: #24909d&#34;&gt;make&lt;/span&gt;&lt;span style=&#34;color: #d0d0d0&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color: #6ab825; font-weight: bold&#34;&gt;chan&lt;/span&gt; &lt;span style=&#34;color: #6ab825; font-weight: bold&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color: #d0d0d0&#34;&gt;)&lt;/span&gt;            &lt;span style=&#34;color: #999999; font-style: italic&#34;&gt;// 정수형의 언버퍼드 채널&lt;/span&gt;
&lt;span style=&#34;color: #d0d0d0&#34;&gt;cj&lt;/span&gt; &lt;span style=&#34;color: #d0d0d0&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color: #24909d&#34;&gt;make&lt;/span&gt;&lt;span style=&#34;color: #d0d0d0&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color: #6ab825; font-weight: bold&#34;&gt;chan&lt;/span&gt; &lt;span style=&#34;color: #6ab825; font-weight: bold&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color: #d0d0d0&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color: #3677a9&#34;&gt;0&lt;/span&gt;&lt;span style=&#34;color: #d0d0d0&#34;&gt;)&lt;/span&gt;         &lt;span style=&#34;color: #999999; font-style: italic&#34;&gt;// 정수형의 언버퍼드 채널&lt;/span&gt;
&lt;span style=&#34;color: #d0d0d0&#34;&gt;cs&lt;/span&gt; &lt;span style=&#34;color: #d0d0d0&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color: #24909d&#34;&gt;make&lt;/span&gt;&lt;span style=&#34;color: #d0d0d0&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color: #6ab825; font-weight: bold&#34;&gt;chan&lt;/span&gt; &lt;span style=&#34;color: #d0d0d0&#34;&gt;*os.File,&lt;/span&gt; &lt;span style=&#34;color: #3677a9&#34;&gt;100&lt;/span&gt;&lt;span style=&#34;color: #d0d0d0&#34;&gt;)&lt;/span&gt;  &lt;span style=&#34;color: #999999; font-style: italic&#34;&gt;// File 포인터형의 버퍼드 채널&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;언버퍼드 채널은 동기화로 값을 교환하며 두 계산(고루틴들)이 어떤 상태에 있는지 알 수 있다는 것을 보장하는 통신을 결합한다.&lt;/p&gt;

&lt;p&gt;채널을 사용하는 멋있는 Go스러운 코드가 많다. 다음 한 예제로 시작해보자. 이전 섹션에서 백그라운드에서 정렬을 했다. 채널은 정렬이 완료될 때까지 고루틴 실행을 대기시킬 수 있다.&lt;/p&gt;

&lt;div class=&#34;highlight&#34; style=&#34;background: #202020&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span style=&#34;color: #d0d0d0&#34;&gt;c&lt;/span&gt; &lt;span style=&#34;color: #d0d0d0&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color: #24909d&#34;&gt;make&lt;/span&gt;&lt;span style=&#34;color: #d0d0d0&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color: #6ab825; font-weight: bold&#34;&gt;chan&lt;/span&gt; &lt;span style=&#34;color: #6ab825; font-weight: bold&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color: #d0d0d0&#34;&gt;)&lt;/span&gt;  &lt;span style=&#34;color: #999999; font-style: italic&#34;&gt;// 채널을 할당&lt;/span&gt;
&lt;span style=&#34;color: #999999; font-style: italic&#34;&gt;// 고루틴에서 정렬 시작하고 완료되면 채널에 신호를 보냄&lt;/span&gt;
&lt;span style=&#34;color: #6ab825; font-weight: bold&#34;&gt;go&lt;/span&gt; &lt;span style=&#34;color: #6ab825; font-weight: bold&#34;&gt;func&lt;/span&gt;&lt;span style=&#34;color: #d0d0d0&#34;&gt;()&lt;/span&gt; &lt;span style=&#34;color: #d0d0d0&#34;&gt;{&lt;/span&gt;
    &lt;span style=&#34;color: #d0d0d0&#34;&gt;list.Sort()&lt;/span&gt;
    &lt;span style=&#34;color: #d0d0d0&#34;&gt;c&lt;/span&gt; &lt;span style=&#34;color: #d0d0d0&#34;&gt;&amp;lt;-&lt;/span&gt; &lt;span style=&#34;color: #3677a9&#34;&gt;1&lt;/span&gt;  &lt;span style=&#34;color: #999999; font-style: italic&#34;&gt;//  신호를 보내지만 값은 문제가 안됨&lt;/span&gt;
&lt;span style=&#34;color: #d0d0d0&#34;&gt;}()&lt;/span&gt;
&lt;span style=&#34;color: #d0d0d0&#34;&gt;doSomethingForAWhile()&lt;/span&gt;
&lt;span style=&#34;color: #d0d0d0&#34;&gt;&amp;lt;-c&lt;/span&gt;   &lt;span style=&#34;color: #999999; font-style: italic&#34;&gt;// 정렬이 끝날 때까지 기다리고 전달된 값은 버림&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;수신부는 수신할 데이터가 있을 때까지 항상 블락된다. 언버퍼드 채널이면, 송신부는 수신부가 값을 받을 때까지 블락된다. 버퍼드 채널이면, 값이 버퍼에 복사될 때까지만 송신부가 블락된다. 그러므로 버퍼가 꽉 차면, 이는 특정 수신부가 값을 획득할 때까지 대기 중이라는 것을 의미한다.&lt;/p&gt;

&lt;p&gt;버퍼드 채널은 세마포처럼 사용될 수 있다. 예를 들어 처리량을 제한하는 것이다. 다음 예제에서, 들어오는 요청은 값을 채널에 전송하는 &lt;code&gt;handle&lt;/code&gt;에 넘겨진다. 요청을 처리한 후, 다음 (요청) 소비자에 대해 세마포를 준비하는 채널에서 값을 수신한다.&lt;/p&gt;

&lt;div class=&#34;highlight&#34; style=&#34;background: #202020&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span style=&#34;color: #6ab825; font-weight: bold&#34;&gt;var&lt;/span&gt; &lt;span style=&#34;color: #d0d0d0&#34;&gt;sem&lt;/span&gt; &lt;span style=&#34;color: #d0d0d0&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #24909d&#34;&gt;make&lt;/span&gt;&lt;span style=&#34;color: #d0d0d0&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color: #6ab825; font-weight: bold&#34;&gt;chan&lt;/span&gt; &lt;span style=&#34;color: #6ab825; font-weight: bold&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color: #d0d0d0&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color: #d0d0d0&#34;&gt;MaxOutstanding)&lt;/span&gt;

&lt;span style=&#34;color: #6ab825; font-weight: bold&#34;&gt;func&lt;/span&gt; &lt;span style=&#34;color: #d0d0d0&#34;&gt;handle(r&lt;/span&gt; &lt;span style=&#34;color: #d0d0d0&#34;&gt;*Request)&lt;/span&gt; &lt;span style=&#34;color: #d0d0d0&#34;&gt;{&lt;/span&gt;
    &lt;span style=&#34;color: #d0d0d0&#34;&gt;sem&lt;/span&gt; &lt;span style=&#34;color: #d0d0d0&#34;&gt;&amp;lt;-&lt;/span&gt; &lt;span style=&#34;color: #3677a9&#34;&gt;1&lt;/span&gt;    &lt;span style=&#34;color: #999999; font-style: italic&#34;&gt;// 액티브큐가 비워질 때까지 대기&lt;/span&gt;
    &lt;span style=&#34;color: #d0d0d0&#34;&gt;process(r)&lt;/span&gt;  &lt;span style=&#34;color: #999999; font-style: italic&#34;&gt;// 오래 걸릴 수 있는 작업&lt;/span&gt;
    &lt;span style=&#34;color: #d0d0d0&#34;&gt;&amp;lt;-sem&lt;/span&gt;       &lt;span style=&#34;color: #999999; font-style: italic&#34;&gt;// 완료, 실행될 다음 요청을 활성화&lt;/span&gt;
&lt;span style=&#34;color: #d0d0d0&#34;&gt;}&lt;/span&gt;

&lt;span style=&#34;color: #6ab825; font-weight: bold&#34;&gt;func&lt;/span&gt; &lt;span style=&#34;color: #d0d0d0&#34;&gt;Serve(queue&lt;/span&gt; &lt;span style=&#34;color: #6ab825; font-weight: bold&#34;&gt;chan&lt;/span&gt; &lt;span style=&#34;color: #d0d0d0&#34;&gt;*Request)&lt;/span&gt; &lt;span style=&#34;color: #d0d0d0&#34;&gt;{&lt;/span&gt;
    &lt;span style=&#34;color: #6ab825; font-weight: bold&#34;&gt;for&lt;/span&gt; &lt;span style=&#34;color: #d0d0d0&#34;&gt;{&lt;/span&gt;
        &lt;span style=&#34;color: #d0d0d0&#34;&gt;req&lt;/span&gt; &lt;span style=&#34;color: #d0d0d0&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color: #d0d0d0&#34;&gt;&amp;lt;-queue&lt;/span&gt;
        &lt;span style=&#34;color: #6ab825; font-weight: bold&#34;&gt;go&lt;/span&gt; &lt;span style=&#34;color: #d0d0d0&#34;&gt;handle(req)&lt;/span&gt;  &lt;span style=&#34;color: #999999; font-style: italic&#34;&gt;// 끝날 때까지 대기하지 않음&lt;/span&gt;
    &lt;span style=&#34;color: #d0d0d0&#34;&gt;}&lt;/span&gt;
&lt;span style=&#34;color: #d0d0d0&#34;&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;일단 MaxOutstanding 핸들러가 &lt;code&gt;process&lt;/code&gt;를 실행하게 되면, 기존 핸들러 중 하나가 완료되고 버퍼로부터 값을 받을 때까지 더 이상의 꽉 찬 채널 버퍼에 전송하는 것은 블락될 것이다.&lt;/p&gt;

&lt;p&gt;그렇지만 이 설계는 문제가 있다. 즉, 전체 요청에서 겨우 &lt;code&gt;MaxOutstanding&lt;/code&gt; 수만큼 &lt;code&gt;process&lt;/code&gt;를 실행할 수 있음에도 서버는 들어오는 모든 요청에 대해 새로운 고루틴을 생성한다는 것이다. 그 결과, 요청이 너무 빨리 들어올 경우, 무제한으로 리소스를 낭비할 수 있다. 이 결함은 &lt;code&gt;Serve&lt;/code&gt;를 고루틴을 생성하는 게이트로 수정해서 처리할 수 있다. 확실한 솔루션은 다음과 같지만, 나중에 수정하게 될 버그가 있다는 것에 주의하라.&lt;/p&gt;

&lt;div class=&#34;highlight&#34; style=&#34;background: #202020&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span style=&#34;color: #6ab825; font-weight: bold&#34;&gt;func&lt;/span&gt; &lt;span style=&#34;color: #d0d0d0&#34;&gt;Serve(queue&lt;/span&gt; &lt;span style=&#34;color: #6ab825; font-weight: bold&#34;&gt;chan&lt;/span&gt; &lt;span style=&#34;color: #d0d0d0&#34;&gt;*Request)&lt;/span&gt; &lt;span style=&#34;color: #d0d0d0&#34;&gt;{&lt;/span&gt;
    &lt;span style=&#34;color: #6ab825; font-weight: bold&#34;&gt;for&lt;/span&gt; &lt;span style=&#34;color: #d0d0d0&#34;&gt;req&lt;/span&gt; &lt;span style=&#34;color: #d0d0d0&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color: #6ab825; font-weight: bold&#34;&gt;range&lt;/span&gt; &lt;span style=&#34;color: #d0d0d0&#34;&gt;queue&lt;/span&gt; &lt;span style=&#34;color: #d0d0d0&#34;&gt;{&lt;/span&gt;
        &lt;span style=&#34;color: #d0d0d0&#34;&gt;sem&lt;/span&gt; &lt;span style=&#34;color: #d0d0d0&#34;&gt;&amp;lt;-&lt;/span&gt; &lt;span style=&#34;color: #3677a9&#34;&gt;1&lt;/span&gt;
        &lt;span style=&#34;color: #6ab825; font-weight: bold&#34;&gt;go&lt;/span&gt; &lt;span style=&#34;color: #6ab825; font-weight: bold&#34;&gt;func&lt;/span&gt;&lt;span style=&#34;color: #d0d0d0&#34;&gt;()&lt;/span&gt; &lt;span style=&#34;color: #d0d0d0&#34;&gt;{&lt;/span&gt;
            &lt;span style=&#34;color: #d0d0d0&#34;&gt;process(req)&lt;/span&gt; &lt;span style=&#34;color: #999999; font-style: italic&#34;&gt;// 버그, 아래 설명을 참고&lt;/span&gt;
            &lt;span style=&#34;color: #d0d0d0&#34;&gt;&amp;lt;-sem&lt;/span&gt;
        &lt;span style=&#34;color: #d0d0d0&#34;&gt;}()&lt;/span&gt;
    &lt;span style=&#34;color: #d0d0d0&#34;&gt;}&lt;/span&gt;
&lt;span style=&#34;color: #d0d0d0&#34;&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;버그는 Go &lt;code&gt;for&lt;/code&gt; 루프에 있다. 루프 변수는 각 반복마다 재사용되어 동일한 &lt;code&gt;req&lt;/code&gt; 변수가 모든 고루틴에 걸쳐 공유된다. 이는 원하는 바가 아니다. 각 고루틴마다 구별된 &lt;code&gt;req&lt;/code&gt; 변수를 가지도록 해야한다. 다음은 이를 위한 한 가지 방법으로, 고루틴의 클로져에 대한 인자로 &lt;code&gt;req&lt;/code&gt;의 값을 전달하는 것이다:&lt;/p&gt;

&lt;div class=&#34;highlight&#34; style=&#34;background: #202020&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span style=&#34;color: #6ab825; font-weight: bold&#34;&gt;func&lt;/span&gt; &lt;span style=&#34;color: #d0d0d0&#34;&gt;Serve(queue&lt;/span&gt; &lt;span style=&#34;color: #6ab825; font-weight: bold&#34;&gt;chan&lt;/span&gt; &lt;span style=&#34;color: #d0d0d0&#34;&gt;*Request)&lt;/span&gt; &lt;span style=&#34;color: #d0d0d0&#34;&gt;{&lt;/span&gt;
    &lt;span style=&#34;color: #6ab825; font-weight: bold&#34;&gt;for&lt;/span&gt; &lt;span style=&#34;color: #d0d0d0&#34;&gt;req&lt;/span&gt; &lt;span style=&#34;color: #d0d0d0&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color: #6ab825; font-weight: bold&#34;&gt;range&lt;/span&gt; &lt;span style=&#34;color: #d0d0d0&#34;&gt;queue&lt;/span&gt; &lt;span style=&#34;color: #d0d0d0&#34;&gt;{&lt;/span&gt;
        &lt;span style=&#34;color: #d0d0d0&#34;&gt;sem&lt;/span&gt; &lt;span style=&#34;color: #d0d0d0&#34;&gt;&amp;lt;-&lt;/span&gt; &lt;span style=&#34;color: #3677a9&#34;&gt;1&lt;/span&gt;
        &lt;span style=&#34;color: #6ab825; font-weight: bold&#34;&gt;go&lt;/span&gt; &lt;span style=&#34;color: #6ab825; font-weight: bold&#34;&gt;func&lt;/span&gt;&lt;span style=&#34;color: #d0d0d0&#34;&gt;(req&lt;/span&gt; &lt;span style=&#34;color: #d0d0d0&#34;&gt;*Request)&lt;/span&gt; &lt;span style=&#34;color: #d0d0d0&#34;&gt;{&lt;/span&gt;
            &lt;span style=&#34;color: #d0d0d0&#34;&gt;process(req)&lt;/span&gt;
            &lt;span style=&#34;color: #d0d0d0&#34;&gt;&amp;lt;-sem&lt;/span&gt;
        &lt;span style=&#34;color: #d0d0d0&#34;&gt;}(req)&lt;/span&gt;
    &lt;span style=&#34;color: #d0d0d0&#34;&gt;}&lt;/span&gt;
&lt;span style=&#34;color: #d0d0d0&#34;&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;이전 버전과 클로져가 어떻게 선언되고 실행되는지 차이점을 보기 위해 다음 버전을 비교해보라. 또다른 솔루션은 다음 예제처럼 그냥 같은 이름의 새로운 변수를 생성하는 것이다.&lt;/p&gt;

&lt;div class=&#34;highlight&#34; style=&#34;background: #202020&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span style=&#34;color: #6ab825; font-weight: bold&#34;&gt;func&lt;/span&gt; &lt;span style=&#34;color: #d0d0d0&#34;&gt;Serve(queue&lt;/span&gt; &lt;span style=&#34;color: #6ab825; font-weight: bold&#34;&gt;chan&lt;/span&gt; &lt;span style=&#34;color: #d0d0d0&#34;&gt;*Request)&lt;/span&gt; &lt;span style=&#34;color: #d0d0d0&#34;&gt;{&lt;/span&gt;
    &lt;span style=&#34;color: #6ab825; font-weight: bold&#34;&gt;for&lt;/span&gt; &lt;span style=&#34;color: #d0d0d0&#34;&gt;req&lt;/span&gt; &lt;span style=&#34;color: #d0d0d0&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color: #6ab825; font-weight: bold&#34;&gt;range&lt;/span&gt; &lt;span style=&#34;color: #d0d0d0&#34;&gt;queue&lt;/span&gt; &lt;span style=&#34;color: #d0d0d0&#34;&gt;{&lt;/span&gt;
        &lt;span style=&#34;color: #d0d0d0&#34;&gt;req&lt;/span&gt; &lt;span style=&#34;color: #d0d0d0&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color: #d0d0d0&#34;&gt;req&lt;/span&gt; &lt;span style=&#34;color: #999999; font-style: italic&#34;&gt;// 고루틴을 위한 새로운 req 인스턴스를 생성&lt;/span&gt;
        &lt;span style=&#34;color: #d0d0d0&#34;&gt;sem&lt;/span&gt; &lt;span style=&#34;color: #d0d0d0&#34;&gt;&amp;lt;-&lt;/span&gt; &lt;span style=&#34;color: #3677a9&#34;&gt;1&lt;/span&gt;
        &lt;span style=&#34;color: #6ab825; font-weight: bold&#34;&gt;go&lt;/span&gt; &lt;span style=&#34;color: #6ab825; font-weight: bold&#34;&gt;func&lt;/span&gt;&lt;span style=&#34;color: #d0d0d0&#34;&gt;()&lt;/span&gt; &lt;span style=&#34;color: #d0d0d0&#34;&gt;{&lt;/span&gt;
            &lt;span style=&#34;color: #d0d0d0&#34;&gt;process(req)&lt;/span&gt;
            &lt;span style=&#34;color: #d0d0d0&#34;&gt;&amp;lt;-sem&lt;/span&gt;
        &lt;span style=&#34;color: #d0d0d0&#34;&gt;}()&lt;/span&gt;
    &lt;span style=&#34;color: #d0d0d0&#34;&gt;}&lt;/span&gt;
&lt;span style=&#34;color: #d0d0d0&#34;&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;이상한 코드를 작성하는 것처럼 보일 수 있다.&lt;/p&gt;

&lt;div class=&#34;highlight&#34; style=&#34;background: #202020&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span style=&#34;color: #d0d0d0&#34;&gt;req&lt;/span&gt; &lt;span style=&#34;color: #d0d0d0&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color: #d0d0d0&#34;&gt;req&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;하지만 Go에서 이렇게 하는 것은 합법적이고 Go 언어다운 코드이다. 이름이 같은 새로운 버전의 변수가 의도적으로 루프 변수를 지역적으로 가리지만, 각 고루틴에 대해서는 유니크한 값이다.&lt;/p&gt;

&lt;p&gt;서버를 작성하는 일반적인 문제로 돌아가면, 리소스를 잘 관리하는 다른 방법은 요청 채널을 읽는 모든 &lt;code&gt;handle&lt;/code&gt; 고루틴을 고정된 수에서 시작하는 것이다. 고루틴의 수는 &lt;code&gt;process&lt;/code&gt;가 동시에 호출되는 수를 제한한다. &lt;code&gt;Serve&lt;/code&gt; 함수는 종료 신호를 수신하게 되는 채널도 (인자로) 받고 있으므로 고루틴이 시작되면, 이 채널로부터의 수신은 블락된다.&lt;/p&gt;

&lt;div class=&#34;highlight&#34; style=&#34;background: #202020&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span style=&#34;color: #6ab825; font-weight: bold&#34;&gt;func&lt;/span&gt; &lt;span style=&#34;color: #d0d0d0&#34;&gt;handle(queue&lt;/span&gt; &lt;span style=&#34;color: #6ab825; font-weight: bold&#34;&gt;chan&lt;/span&gt; &lt;span style=&#34;color: #d0d0d0&#34;&gt;*Request)&lt;/span&gt; &lt;span style=&#34;color: #d0d0d0&#34;&gt;{&lt;/span&gt;
    &lt;span style=&#34;color: #6ab825; font-weight: bold&#34;&gt;for&lt;/span&gt; &lt;span style=&#34;color: #d0d0d0&#34;&gt;r&lt;/span&gt; &lt;span style=&#34;color: #d0d0d0&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color: #6ab825; font-weight: bold&#34;&gt;range&lt;/span&gt; &lt;span style=&#34;color: #d0d0d0&#34;&gt;queue&lt;/span&gt; &lt;span style=&#34;color: #d0d0d0&#34;&gt;{&lt;/span&gt;
        &lt;span style=&#34;color: #d0d0d0&#34;&gt;process(r)&lt;/span&gt;
    &lt;span style=&#34;color: #d0d0d0&#34;&gt;}&lt;/span&gt;
&lt;span style=&#34;color: #d0d0d0&#34;&gt;}&lt;/span&gt;

&lt;span style=&#34;color: #6ab825; font-weight: bold&#34;&gt;func&lt;/span&gt; &lt;span style=&#34;color: #d0d0d0&#34;&gt;Serve(clientRequests&lt;/span&gt; &lt;span style=&#34;color: #6ab825; font-weight: bold&#34;&gt;chan&lt;/span&gt; &lt;span style=&#34;color: #d0d0d0&#34;&gt;*Request,&lt;/span&gt; &lt;span style=&#34;color: #d0d0d0&#34;&gt;quit&lt;/span&gt; &lt;span style=&#34;color: #6ab825; font-weight: bold&#34;&gt;chan&lt;/span&gt; &lt;span style=&#34;color: #6ab825; font-weight: bold&#34;&gt;bool&lt;/span&gt;&lt;span style=&#34;color: #d0d0d0&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color: #d0d0d0&#34;&gt;{&lt;/span&gt;
    &lt;span style=&#34;color: #999999; font-style: italic&#34;&gt;// 핸들러 시작&lt;/span&gt;
    &lt;span style=&#34;color: #6ab825; font-weight: bold&#34;&gt;for&lt;/span&gt; &lt;span style=&#34;color: #d0d0d0&#34;&gt;i&lt;/span&gt; &lt;span style=&#34;color: #d0d0d0&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color: #3677a9&#34;&gt;0&lt;/span&gt;&lt;span style=&#34;color: #d0d0d0&#34;&gt;;&lt;/span&gt; &lt;span style=&#34;color: #d0d0d0&#34;&gt;i&lt;/span&gt; &lt;span style=&#34;color: #d0d0d0&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color: #d0d0d0&#34;&gt;MaxOutstanding;&lt;/span&gt; &lt;span style=&#34;color: #d0d0d0&#34;&gt;i++&lt;/span&gt; &lt;span style=&#34;color: #d0d0d0&#34;&gt;{&lt;/span&gt;
        &lt;span style=&#34;color: #6ab825; font-weight: bold&#34;&gt;go&lt;/span&gt; &lt;span style=&#34;color: #d0d0d0&#34;&gt;handle(clientRequests)&lt;/span&gt;
    &lt;span style=&#34;color: #d0d0d0&#34;&gt;}&lt;/span&gt;
    &lt;span style=&#34;color: #d0d0d0&#34;&gt;&amp;lt;-quit&lt;/span&gt;  &lt;span style=&#34;color: #999999; font-style: italic&#34;&gt;// 종료 신호를 받을 때까지 대기&lt;/span&gt;
&lt;span style=&#34;color: #d0d0d0&#34;&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h2 id=&#34;채널의-채널-channels-of-channels&#34;&gt;채널의 채널 (Channels of channels)&lt;/h2&gt;

&lt;p&gt;Go의 가장 중요한 속성 중 하나는 채널이 다른 것과 마찬가지로 할당되고 전달될 수 있는 일급변수(first-class value)라는 것이다. 이 속성의 일반적인 사용은 안전한 병렬 역다중화(parallel demultiplexing)를 구현하는 것이다.&lt;/p&gt;

&lt;p&gt;이전 섹션의 예제에서, &lt;code&gt;handle&lt;/code&gt; 은 요청에 대해서는 이상적인 핸들러였으나 핸들러가 다루는 타입은 정의하지 않았다. 해당 타입이 회신을 하는 채널을 포함하는 경우, 각 클라이언트는 자신에게 응답 경로를 제공할 수 있다. 다음은 &lt;code&gt;Request&lt;/code&gt; 타입의 개략적인 정의이다.&lt;/p&gt;

&lt;div class=&#34;highlight&#34; style=&#34;background: #202020&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span style=&#34;color: #6ab825; font-weight: bold&#34;&gt;type&lt;/span&gt; &lt;span style=&#34;color: #d0d0d0&#34;&gt;Request&lt;/span&gt; &lt;span style=&#34;color: #6ab825; font-weight: bold&#34;&gt;struct&lt;/span&gt; &lt;span style=&#34;color: #d0d0d0&#34;&gt;{&lt;/span&gt;
    &lt;span style=&#34;color: #d0d0d0&#34;&gt;args&lt;/span&gt;        &lt;span style=&#34;color: #d0d0d0&#34;&gt;[]&lt;/span&gt;&lt;span style=&#34;color: #6ab825; font-weight: bold&#34;&gt;int&lt;/span&gt;
    &lt;span style=&#34;color: #d0d0d0&#34;&gt;f&lt;/span&gt;           &lt;span style=&#34;color: #6ab825; font-weight: bold&#34;&gt;func&lt;/span&gt;&lt;span style=&#34;color: #d0d0d0&#34;&gt;([]&lt;/span&gt;&lt;span style=&#34;color: #6ab825; font-weight: bold&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color: #d0d0d0&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color: #6ab825; font-weight: bold&#34;&gt;int&lt;/span&gt;
    &lt;span style=&#34;color: #d0d0d0&#34;&gt;resultChan&lt;/span&gt;  &lt;span style=&#34;color: #6ab825; font-weight: bold&#34;&gt;chan&lt;/span&gt; &lt;span style=&#34;color: #6ab825; font-weight: bold&#34;&gt;int&lt;/span&gt;
&lt;span style=&#34;color: #d0d0d0&#34;&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;클라이언트는 함수와 그 인자뿐만 아니라 요청 객체 안에서 응답을 수신하는 채널을 제공하고 있다.&lt;/p&gt;

&lt;div class=&#34;highlight&#34; style=&#34;background: #202020&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span style=&#34;color: #6ab825; font-weight: bold&#34;&gt;func&lt;/span&gt; &lt;span style=&#34;color: #d0d0d0&#34;&gt;sum(a&lt;/span&gt; &lt;span style=&#34;color: #d0d0d0&#34;&gt;[]&lt;/span&gt;&lt;span style=&#34;color: #6ab825; font-weight: bold&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color: #d0d0d0&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color: #d0d0d0&#34;&gt;(s&lt;/span&gt; &lt;span style=&#34;color: #6ab825; font-weight: bold&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color: #d0d0d0&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color: #d0d0d0&#34;&gt;{&lt;/span&gt;
    &lt;span style=&#34;color: #6ab825; font-weight: bold&#34;&gt;for&lt;/span&gt; &lt;span style=&#34;color: #d0d0d0&#34;&gt;_,&lt;/span&gt; &lt;span style=&#34;color: #d0d0d0&#34;&gt;v&lt;/span&gt; &lt;span style=&#34;color: #d0d0d0&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color: #6ab825; font-weight: bold&#34;&gt;range&lt;/span&gt; &lt;span style=&#34;color: #d0d0d0&#34;&gt;a&lt;/span&gt; &lt;span style=&#34;color: #d0d0d0&#34;&gt;{&lt;/span&gt;
        &lt;span style=&#34;color: #d0d0d0&#34;&gt;s&lt;/span&gt; &lt;span style=&#34;color: #d0d0d0&#34;&gt;+=&lt;/span&gt; &lt;span style=&#34;color: #d0d0d0&#34;&gt;v&lt;/span&gt;
    &lt;span style=&#34;color: #d0d0d0&#34;&gt;}&lt;/span&gt;
    &lt;span style=&#34;color: #6ab825; font-weight: bold&#34;&gt;return&lt;/span&gt;
&lt;span style=&#34;color: #d0d0d0&#34;&gt;}&lt;/span&gt;

&lt;span style=&#34;color: #d0d0d0&#34;&gt;request&lt;/span&gt; &lt;span style=&#34;color: #d0d0d0&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color: #d0d0d0&#34;&gt;&amp;amp;Request{[]&lt;/span&gt;&lt;span style=&#34;color: #6ab825; font-weight: bold&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color: #d0d0d0&#34;&gt;{&lt;/span&gt;&lt;span style=&#34;color: #3677a9&#34;&gt;3&lt;/span&gt;&lt;span style=&#34;color: #d0d0d0&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color: #3677a9&#34;&gt;4&lt;/span&gt;&lt;span style=&#34;color: #d0d0d0&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color: #3677a9&#34;&gt;5&lt;/span&gt;&lt;span style=&#34;color: #d0d0d0&#34;&gt;},&lt;/span&gt; &lt;span style=&#34;color: #d0d0d0&#34;&gt;sum,&lt;/span&gt; &lt;span style=&#34;color: #24909d&#34;&gt;make&lt;/span&gt;&lt;span style=&#34;color: #d0d0d0&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color: #6ab825; font-weight: bold&#34;&gt;chan&lt;/span&gt; &lt;span style=&#34;color: #6ab825; font-weight: bold&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color: #d0d0d0&#34;&gt;)}&lt;/span&gt;
&lt;span style=&#34;color: #999999; font-style: italic&#34;&gt;// 요청 전송&lt;/span&gt;
&lt;span style=&#34;color: #d0d0d0&#34;&gt;clientRequests&lt;/span&gt; &lt;span style=&#34;color: #d0d0d0&#34;&gt;&amp;lt;-&lt;/span&gt; &lt;span style=&#34;color: #d0d0d0&#34;&gt;request&lt;/span&gt;
&lt;span style=&#34;color: #999999; font-style: italic&#34;&gt;// 응답 대기&lt;/span&gt;
&lt;span style=&#34;color: #d0d0d0&#34;&gt;fmt.Printf(&lt;/span&gt;&lt;span style=&#34;color: #ed9d13&#34;&gt;&amp;quot;answer: %d\n&amp;quot;&lt;/span&gt;&lt;span style=&#34;color: #d0d0d0&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color: #d0d0d0&#34;&gt;&amp;lt;-request.resultChan)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;서버 측에서는 핸들러 함수만 수정한다.&lt;/p&gt;

&lt;div class=&#34;highlight&#34; style=&#34;background: #202020&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span style=&#34;color: #6ab825; font-weight: bold&#34;&gt;func&lt;/span&gt; &lt;span style=&#34;color: #d0d0d0&#34;&gt;handle(queue&lt;/span&gt; &lt;span style=&#34;color: #6ab825; font-weight: bold&#34;&gt;chan&lt;/span&gt; &lt;span style=&#34;color: #d0d0d0&#34;&gt;*Request)&lt;/span&gt; &lt;span style=&#34;color: #d0d0d0&#34;&gt;{&lt;/span&gt;
    &lt;span style=&#34;color: #6ab825; font-weight: bold&#34;&gt;for&lt;/span&gt; &lt;span style=&#34;color: #d0d0d0&#34;&gt;req&lt;/span&gt; &lt;span style=&#34;color: #d0d0d0&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color: #6ab825; font-weight: bold&#34;&gt;range&lt;/span&gt; &lt;span style=&#34;color: #d0d0d0&#34;&gt;queue&lt;/span&gt; &lt;span style=&#34;color: #d0d0d0&#34;&gt;{&lt;/span&gt;
        &lt;span style=&#34;color: #d0d0d0&#34;&gt;req.resultChan&lt;/span&gt; &lt;span style=&#34;color: #d0d0d0&#34;&gt;&amp;lt;-&lt;/span&gt; &lt;span style=&#34;color: #d0d0d0&#34;&gt;req.f(req.args)&lt;/span&gt;
    &lt;span style=&#34;color: #d0d0d0&#34;&gt;}&lt;/span&gt;
&lt;span style=&#34;color: #d0d0d0&#34;&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;실제로 사용하기 위해서는 아직 할 일이 많은 것이 명백하지만, 이 코드는 속도 제한, 병렬, 넌블락 RPC 시스템을 위한 프레임워크이다. 그리고 뮤텍스는 눈에 보이지 않는다.&lt;/p&gt;

&lt;h2 id=&#34;병렬화-parallelization&#34;&gt;병렬화 (Parallelization)&lt;/h2&gt;

&lt;p&gt;이러한 아이디어의 또 다른 응용 프로그램은 멀티코어 CPU에 대해 계산을 병렬처리하는 것이다. 계산을 독립적으로 실행할 수 있는 부분들로 분리할 수 있다면, 각 부분들이 완료될 때 신호를 보내는 채널들로 병렬처리할 수 있다.&lt;/p&gt;

&lt;p&gt;벡터 아이템에 대한 실행 비용이 비싼 연산이 있다고 가정해보자. 그리고 다음 이상적인 예제에서와 같이 각 아이템을 연산한 값은 독립적이다.&lt;/p&gt;

&lt;div class=&#34;highlight&#34; style=&#34;background: #202020&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span style=&#34;color: #6ab825; font-weight: bold&#34;&gt;type&lt;/span&gt; &lt;span style=&#34;color: #d0d0d0&#34;&gt;Vector&lt;/span&gt; &lt;span style=&#34;color: #d0d0d0&#34;&gt;[]&lt;/span&gt;&lt;span style=&#34;color: #6ab825; font-weight: bold&#34;&gt;float64&lt;/span&gt;

&lt;span style=&#34;color: #999999; font-style: italic&#34;&gt;//  v[i], v[i+1]에서 v[n-1]까지 연산을 적용&lt;/span&gt;
&lt;span style=&#34;color: #6ab825; font-weight: bold&#34;&gt;func&lt;/span&gt; &lt;span style=&#34;color: #d0d0d0&#34;&gt;(v&lt;/span&gt; &lt;span style=&#34;color: #d0d0d0&#34;&gt;Vector)&lt;/span&gt; &lt;span style=&#34;color: #d0d0d0&#34;&gt;DoSome(i,&lt;/span&gt; &lt;span style=&#34;color: #d0d0d0&#34;&gt;n&lt;/span&gt; &lt;span style=&#34;color: #6ab825; font-weight: bold&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color: #d0d0d0&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color: #d0d0d0&#34;&gt;u&lt;/span&gt; &lt;span style=&#34;color: #d0d0d0&#34;&gt;Vector,&lt;/span&gt; &lt;span style=&#34;color: #d0d0d0&#34;&gt;c&lt;/span&gt; &lt;span style=&#34;color: #6ab825; font-weight: bold&#34;&gt;chan&lt;/span&gt; &lt;span style=&#34;color: #6ab825; font-weight: bold&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color: #d0d0d0&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color: #d0d0d0&#34;&gt;{&lt;/span&gt;
    &lt;span style=&#34;color: #6ab825; font-weight: bold&#34;&gt;for&lt;/span&gt; &lt;span style=&#34;color: #d0d0d0&#34;&gt;;&lt;/span&gt; &lt;span style=&#34;color: #d0d0d0&#34;&gt;i&lt;/span&gt; &lt;span style=&#34;color: #d0d0d0&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color: #d0d0d0&#34;&gt;n;&lt;/span&gt; &lt;span style=&#34;color: #d0d0d0&#34;&gt;i++&lt;/span&gt; &lt;span style=&#34;color: #d0d0d0&#34;&gt;{&lt;/span&gt;
        &lt;span style=&#34;color: #d0d0d0&#34;&gt;v[i]&lt;/span&gt; &lt;span style=&#34;color: #d0d0d0&#34;&gt;+=&lt;/span&gt; &lt;span style=&#34;color: #d0d0d0&#34;&gt;u.Op(v[i])&lt;/span&gt;
    &lt;span style=&#34;color: #d0d0d0&#34;&gt;}&lt;/span&gt;
    &lt;span style=&#34;color: #d0d0d0&#34;&gt;c&lt;/span&gt; &lt;span style=&#34;color: #d0d0d0&#34;&gt;&amp;lt;-&lt;/span&gt; &lt;span style=&#34;color: #3677a9&#34;&gt;1&lt;/span&gt;    &lt;span style=&#34;color: #999999; font-style: italic&#34;&gt;// 이 부분이 완료되면 신호함&lt;/span&gt;
&lt;span style=&#34;color: #d0d0d0&#34;&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;루프에서 독립적으로 각 부분들을 CPU당 하나씩 실행시킨다. 이들은 어떤 순서로도 완료될 수 있지만 순서는 문제되지 않는다. 그러므로 모든 고루틴를 실행시킨 후 채널을 비워서 그냥 완료 신호를 카운트한다.&lt;/p&gt;

&lt;div class=&#34;highlight&#34; style=&#34;background: #202020&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span style=&#34;color: #6ab825; font-weight: bold&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color: #d0d0d0&#34;&gt;numCPU&lt;/span&gt; &lt;span style=&#34;color: #d0d0d0&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #3677a9&#34;&gt;4&lt;/span&gt; &lt;span style=&#34;color: #999999; font-style: italic&#34;&gt;// CPU  코어수&lt;/span&gt;

&lt;span style=&#34;color: #6ab825; font-weight: bold&#34;&gt;func&lt;/span&gt; &lt;span style=&#34;color: #d0d0d0&#34;&gt;(v&lt;/span&gt; &lt;span style=&#34;color: #d0d0d0&#34;&gt;Vector)&lt;/span&gt; &lt;span style=&#34;color: #d0d0d0&#34;&gt;DoAll(u&lt;/span&gt; &lt;span style=&#34;color: #d0d0d0&#34;&gt;Vector)&lt;/span&gt; &lt;span style=&#34;color: #d0d0d0&#34;&gt;{&lt;/span&gt;
    &lt;span style=&#34;color: #d0d0d0&#34;&gt;c&lt;/span&gt; &lt;span style=&#34;color: #d0d0d0&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color: #24909d&#34;&gt;make&lt;/span&gt;&lt;span style=&#34;color: #d0d0d0&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color: #6ab825; font-weight: bold&#34;&gt;chan&lt;/span&gt; &lt;span style=&#34;color: #6ab825; font-weight: bold&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color: #d0d0d0&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color: #d0d0d0&#34;&gt;numCPU)&lt;/span&gt;  &lt;span style=&#34;color: #999999; font-style: italic&#34;&gt;// 버퍼는 선택적이나 상식적&lt;/span&gt;
    &lt;span style=&#34;color: #6ab825; font-weight: bold&#34;&gt;for&lt;/span&gt; &lt;span style=&#34;color: #d0d0d0&#34;&gt;i&lt;/span&gt; &lt;span style=&#34;color: #d0d0d0&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color: #3677a9&#34;&gt;0&lt;/span&gt;&lt;span style=&#34;color: #d0d0d0&#34;&gt;;&lt;/span&gt; &lt;span style=&#34;color: #d0d0d0&#34;&gt;i&lt;/span&gt; &lt;span style=&#34;color: #d0d0d0&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color: #d0d0d0&#34;&gt;numCPU;&lt;/span&gt; &lt;span style=&#34;color: #d0d0d0&#34;&gt;i++&lt;/span&gt; &lt;span style=&#34;color: #d0d0d0&#34;&gt;{&lt;/span&gt;
        &lt;span style=&#34;color: #6ab825; font-weight: bold&#34;&gt;go&lt;/span&gt; &lt;span style=&#34;color: #d0d0d0&#34;&gt;v.DoSome(i*&lt;/span&gt;&lt;span style=&#34;color: #24909d&#34;&gt;len&lt;/span&gt;&lt;span style=&#34;color: #d0d0d0&#34;&gt;(v)/numCPU,&lt;/span&gt; &lt;span style=&#34;color: #d0d0d0&#34;&gt;(i+&lt;/span&gt;&lt;span style=&#34;color: #3677a9&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color: #d0d0d0&#34;&gt;)*&lt;/span&gt;&lt;span style=&#34;color: #24909d&#34;&gt;len&lt;/span&gt;&lt;span style=&#34;color: #d0d0d0&#34;&gt;(v)/numCPU,&lt;/span&gt; &lt;span style=&#34;color: #d0d0d0&#34;&gt;u,&lt;/span&gt; &lt;span style=&#34;color: #d0d0d0&#34;&gt;c)&lt;/span&gt;
    &lt;span style=&#34;color: #d0d0d0&#34;&gt;}&lt;/span&gt;
    &lt;span style=&#34;color: #999999; font-style: italic&#34;&gt;// 채널을 비움&lt;/span&gt;
    &lt;span style=&#34;color: #6ab825; font-weight: bold&#34;&gt;for&lt;/span&gt; &lt;span style=&#34;color: #d0d0d0&#34;&gt;i&lt;/span&gt; &lt;span style=&#34;color: #d0d0d0&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color: #3677a9&#34;&gt;0&lt;/span&gt;&lt;span style=&#34;color: #d0d0d0&#34;&gt;;&lt;/span&gt; &lt;span style=&#34;color: #d0d0d0&#34;&gt;i&lt;/span&gt; &lt;span style=&#34;color: #d0d0d0&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color: #d0d0d0&#34;&gt;numCPU;&lt;/span&gt; &lt;span style=&#34;color: #d0d0d0&#34;&gt;i++&lt;/span&gt; &lt;span style=&#34;color: #d0d0d0&#34;&gt;{&lt;/span&gt;
        &lt;span style=&#34;color: #d0d0d0&#34;&gt;&amp;lt;-c&lt;/span&gt;    &lt;span style=&#34;color: #999999; font-style: italic&#34;&gt;// 한 태스크가 끝날 때까지 대기&lt;/span&gt;
    &lt;span style=&#34;color: #d0d0d0&#34;&gt;}&lt;/span&gt;
    &lt;span style=&#34;color: #999999; font-style: italic&#34;&gt;// 모두 완료&lt;/span&gt;
&lt;span style=&#34;color: #d0d0d0&#34;&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;code&gt;numCPU&lt;/code&gt;을 상수값으로 생성하기보다는 적절한 값을 런타임시에 요구할 수 있다. &lt;code&gt;runtime.NumCPU&lt;/code&gt; 함수는 장비의 CPU 하드웨어 코어수를 반환한다. 그래서 아래와 같이 작성할 수 있다.&lt;/p&gt;

&lt;div class=&#34;highlight&#34; style=&#34;background: #202020&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span style=&#34;color: #6ab825; font-weight: bold&#34;&gt;var&lt;/span&gt; &lt;span style=&#34;color: #d0d0d0&#34;&gt;numCPU&lt;/span&gt; &lt;span style=&#34;color: #d0d0d0&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #d0d0d0&#34;&gt;runtime.NumCPU()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;또한 Go 프로그램은 동시에 실행할 수 있는 사용자 지정 코어수를 보고하는 (또는 설정하는) &lt;code&gt;runtime.GOMAXPROCS&lt;/code&gt; 함수가 있다. &lt;code&gt;runtime.NumCPU&lt;/code&gt;의 값이 기본값이지만, 비슷하게 명명된 환경 변수 설정에 의해 혹은 양수의 인자로 함수를 호출하여 재정의할 수 있다. 0으로 호출하면 바로 값을 조회한다. 따라서 사용자의 리소스 요청을 따르고 싶은 경우, 다음과 같이 작성해야 한다.&lt;/p&gt;

&lt;div class=&#34;highlight&#34; style=&#34;background: #202020&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span style=&#34;color: #6ab825; font-weight: bold&#34;&gt;var&lt;/span&gt; &lt;span style=&#34;color: #d0d0d0&#34;&gt;numCPU&lt;/span&gt; &lt;span style=&#34;color: #d0d0d0&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #d0d0d0&#34;&gt;runtime.GOMAXPROCS(&lt;/span&gt;&lt;span style=&#34;color: #3677a9&#34;&gt;0&lt;/span&gt;&lt;span style=&#34;color: #d0d0d0&#34;&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;컴포넌트를 독립적으로 처리하여 프로그램을 구조화하는 동시성과 다중 CPU에서 효율성을 위해 계산을 병렬로 처리하는 병렬성의 개념을 혼동하지 않길 바란다. Go의 동시성 특징이 병렬 계산으로 문제를 쉽게 구조화할 수 있지만, Go는 병렬이 아닌 동시성 언어이고, 모든 병렬화 문제가 Go에 들어맞지는 않는다. 이 구분에 대한 논의는 &lt;a href=&#34;https://blog.golang.org/concurrency-is-not-parallelism&#34;&gt;이 블로그 포스트&lt;/a&gt;에 인용된 토크를 참조하라.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;역자 주&lt;/strong&gt;: 동시성 프로그래밍과 병렬 프로그래밍의 차이는 아래 그림을 참조 (&lt;a href=&#34;http://joearms.github.io/2013/04/05/concurrent-and-parallel-programming.html&#34;&gt;출처&lt;/a&gt;)&lt;/p&gt;


&lt;figure &gt;
    
        &lt;img src=&#34;http://joearms.github.io/images/con_and_par.jpg&#34; /&gt;
    
    
&lt;/figure&gt;


&lt;h2 id=&#34;누설-버퍼-a-leaky-buffer&#34;&gt;누설 버퍼 (A leaky buffer)&lt;/h2&gt;

&lt;p&gt;비동시성(non-concurrent) 개념도 동시성 프로그래밍 도구로 쉽게 표현할 수 있다. 다음은 RPC 패키지에서 추출한 예제이다. 클라이언트 고루틴은 아마도 네트워크인 특정 소스의 데이터를 반복해서 수신한다. 버퍼의 할당과 해제를 피하기 위해서 &lt;code&gt;free list&lt;/code&gt;를 유지하며 이를 대신할 버퍼 채널을 사용한다. 채널이 비어 있으면 새로운 버퍼가 할당된다. 일단 메시지 버퍼가 준비되면 &lt;code&gt;serverChan&lt;/code&gt;의 서버로 송신한다.&lt;/p&gt;

&lt;div class=&#34;highlight&#34; style=&#34;background: #202020&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span style=&#34;color: #6ab825; font-weight: bold&#34;&gt;var&lt;/span&gt; &lt;span style=&#34;color: #d0d0d0&#34;&gt;freeList&lt;/span&gt; &lt;span style=&#34;color: #d0d0d0&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #24909d&#34;&gt;make&lt;/span&gt;&lt;span style=&#34;color: #d0d0d0&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color: #6ab825; font-weight: bold&#34;&gt;chan&lt;/span&gt; &lt;span style=&#34;color: #d0d0d0&#34;&gt;*Buffer,&lt;/span&gt; &lt;span style=&#34;color: #3677a9&#34;&gt;100&lt;/span&gt;&lt;span style=&#34;color: #d0d0d0&#34;&gt;)&lt;/span&gt;
&lt;span style=&#34;color: #6ab825; font-weight: bold&#34;&gt;var&lt;/span&gt; &lt;span style=&#34;color: #d0d0d0&#34;&gt;serverChan&lt;/span&gt; &lt;span style=&#34;color: #d0d0d0&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #24909d&#34;&gt;make&lt;/span&gt;&lt;span style=&#34;color: #d0d0d0&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color: #6ab825; font-weight: bold&#34;&gt;chan&lt;/span&gt; &lt;span style=&#34;color: #d0d0d0&#34;&gt;*Buffer)&lt;/span&gt;

&lt;span style=&#34;color: #6ab825; font-weight: bold&#34;&gt;func&lt;/span&gt; &lt;span style=&#34;color: #d0d0d0&#34;&gt;client()&lt;/span&gt; &lt;span style=&#34;color: #d0d0d0&#34;&gt;{&lt;/span&gt;
    &lt;span style=&#34;color: #6ab825; font-weight: bold&#34;&gt;for&lt;/span&gt; &lt;span style=&#34;color: #d0d0d0&#34;&gt;{&lt;/span&gt;
        &lt;span style=&#34;color: #6ab825; font-weight: bold&#34;&gt;var&lt;/span&gt; &lt;span style=&#34;color: #d0d0d0&#34;&gt;b&lt;/span&gt; &lt;span style=&#34;color: #d0d0d0&#34;&gt;*Buffer&lt;/span&gt;
        &lt;span style=&#34;color: #999999; font-style: italic&#34;&gt;// 사용할 수 있는 버퍼를 획득하거나 그렇지 않다면 할당&lt;/span&gt;
        &lt;span style=&#34;color: #6ab825; font-weight: bold&#34;&gt;select&lt;/span&gt; &lt;span style=&#34;color: #d0d0d0&#34;&gt;{&lt;/span&gt;
            &lt;span style=&#34;color: #6ab825; font-weight: bold&#34;&gt;case&lt;/span&gt; &lt;span style=&#34;color: #d0d0d0&#34;&gt;b&lt;/span&gt; &lt;span style=&#34;color: #d0d0d0&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #d0d0d0&#34;&gt;&amp;lt;-freeList:&lt;/span&gt;
                &lt;span style=&#34;color: #999999; font-style: italic&#34;&gt;// 하나를 획득하고 아무 작업도 하지 않음&lt;/span&gt;
            &lt;span style=&#34;color: #6ab825; font-weight: bold&#34;&gt;default&lt;/span&gt;&lt;span style=&#34;color: #d0d0d0&#34;&gt;:&lt;/span&gt;
                &lt;span style=&#34;color: #999999; font-style: italic&#34;&gt;// 획득할 버퍼가 없으니 새 버퍼를 할당함&lt;/span&gt;
            &lt;span style=&#34;color: #d0d0d0&#34;&gt;b&lt;/span&gt; &lt;span style=&#34;color: #d0d0d0&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #24909d&#34;&gt;new&lt;/span&gt;&lt;span style=&#34;color: #d0d0d0&#34;&gt;(Buffer)&lt;/span&gt;
        &lt;span style=&#34;color: #d0d0d0&#34;&gt;}&lt;/span&gt;
        &lt;span style=&#34;color: #d0d0d0&#34;&gt;load(b)&lt;/span&gt;              &lt;span style=&#34;color: #999999; font-style: italic&#34;&gt;// 네트워크에서 다음 메세지를 읽음&lt;/span&gt;
        &lt;span style=&#34;color: #d0d0d0&#34;&gt;serverChan&lt;/span&gt; &lt;span style=&#34;color: #d0d0d0&#34;&gt;&amp;lt;-&lt;/span&gt; &lt;span style=&#34;color: #d0d0d0&#34;&gt;b&lt;/span&gt;      &lt;span style=&#34;color: #999999; font-style: italic&#34;&gt;// 서버에 전송&lt;/span&gt;
    &lt;span style=&#34;color: #d0d0d0&#34;&gt;}&lt;/span&gt;
&lt;span style=&#34;color: #d0d0d0&#34;&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;서버 루프는 각 클라이언트로부터 메시지를 수신해서 처리하고, free list에 버퍼를 반환한다.&lt;/p&gt;

&lt;div class=&#34;highlight&#34; style=&#34;background: #202020&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span style=&#34;color: #6ab825; font-weight: bold&#34;&gt;func&lt;/span&gt; &lt;span style=&#34;color: #d0d0d0&#34;&gt;server()&lt;/span&gt; &lt;span style=&#34;color: #d0d0d0&#34;&gt;{&lt;/span&gt;
    &lt;span style=&#34;color: #6ab825; font-weight: bold&#34;&gt;for&lt;/span&gt; &lt;span style=&#34;color: #d0d0d0&#34;&gt;{&lt;/span&gt;
        &lt;span style=&#34;color: #d0d0d0&#34;&gt;b&lt;/span&gt; &lt;span style=&#34;color: #d0d0d0&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color: #d0d0d0&#34;&gt;&amp;lt;-serverChan&lt;/span&gt;    &lt;span style=&#34;color: #999999; font-style: italic&#34;&gt;// 동작을 위해 대기&lt;/span&gt;
        &lt;span style=&#34;color: #d0d0d0&#34;&gt;process(b)&lt;/span&gt;
        &lt;span style=&#34;color: #999999; font-style: italic&#34;&gt;// 가능할 경우 버퍼를 재사용&lt;/span&gt;
        &lt;span style=&#34;color: #6ab825; font-weight: bold&#34;&gt;select&lt;/span&gt; &lt;span style=&#34;color: #d0d0d0&#34;&gt;{&lt;/span&gt;
            &lt;span style=&#34;color: #6ab825; font-weight: bold&#34;&gt;case&lt;/span&gt; &lt;span style=&#34;color: #d0d0d0&#34;&gt;freeList&lt;/span&gt; &lt;span style=&#34;color: #d0d0d0&#34;&gt;&amp;lt;-&lt;/span&gt; &lt;span style=&#34;color: #d0d0d0&#34;&gt;b:&lt;/span&gt;
                &lt;span style=&#34;color: #999999; font-style: italic&#34;&gt;// free list의 버퍼. 아무 것도 하지 않음&lt;/span&gt;
            &lt;span style=&#34;color: #6ab825; font-weight: bold&#34;&gt;default&lt;/span&gt;&lt;span style=&#34;color: #d0d0d0&#34;&gt;:&lt;/span&gt;
                &lt;span style=&#34;color: #999999; font-style: italic&#34;&gt;// free list가 꽉 참, 그냥 계속&lt;/span&gt;
        &lt;span style=&#34;color: #d0d0d0&#34;&gt;}&lt;/span&gt;
    &lt;span style=&#34;color: #d0d0d0&#34;&gt;}&lt;/span&gt;
&lt;span style=&#34;color: #d0d0d0&#34;&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;클라이언트는 &lt;code&gt;freeList&lt;/code&gt;에서 버퍼를 획득하려고 시도하는데, 버퍼를 사용할 수 없는 경우에는 새로운 버퍼를 할당한다. 리스트가 꽉 차 있지 않는 이상, 서버는 버퍼를 &lt;code&gt;freeList&lt;/code&gt;에 송신하여 프리 리스트에 버퍼 b를 다시 둔다. 리스트가 꽉 차 있는 경우, 버퍼는 바닥에 떨어져 가비지 콜렉터에 의해 회수된다. (&lt;code&gt;select&lt;/code&gt; 구문에서 &lt;code&gt;default&lt;/code&gt; 절은 다른 case가 준비되지 않은 경우에 실행된다. 이는 &lt;code&gt;select&lt;/code&gt;는 결코 블락되지 않는다는 것을 뜻한다.)  단지 몇 줄로 버퍼 채널과 버퍼 크기를 부기하는 가비지 컬렉터에 기대어 구현된 누설 버킷 프리 리스트(leaky bucket free list)를 만들었다.&lt;/p&gt;

&lt;p&gt;이상, 나머지는 &lt;a href=&#34;https://gosudaweb.gitbooks.io/effective-go-in-korean/content/&#34;&gt;여기 한글화 문서&lt;/a&gt;를 참조하길 바란다.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Falcon REST API</title>
      <link>https://ziwon.github.io/posts/falcon-rest-template/</link>
      <pubDate>Fri, 04 Sep 2015 00:27:35 +0900</pubDate>
      
      <guid>https://ziwon.github.io/posts/falcon-rest-template/</guid>
      <description>&lt;p&gt;Cloud API와 백엔드 개발에 경량화된 파이썬 프레임워크인 &lt;a href=&#34;http://falconframework.org&#34;&gt;Falcon&lt;/a&gt;를 이용해 간단한 REST API 템플릿을 만들어 보았다.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/patriz/falcon-rest-api&#34;&gt;https://github.com/patriz/falcon-rest-api&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;개발하는 느낌은 Flask와 비슷한데 (음.. Flask와 뭐가 다르지?) 미들웨어, 후킹 데코레이션 등을 이용해 HTTP 요청과 응답에 대해 체이닝 처리를 좀 더 직관적으로 할 수 있다. 성능이 Flask보다 좀 더 빠른 것으로 알려져 있다. Rackspace에서 밀고있는(?) Cloud API 전용 프레임워크인데, 최신 릴리즈 버전은 아직 0.3이다. 심플하고 미니멀한 걸 좋아한다면 해볼만하다.&lt;/p&gt;

&lt;p&gt;문서에도 나와있지만, Cython을 이용하면 약 20% 정도의 성능효과를 볼 수 있다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;pip install --upgrade cython falcon
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;다음은 Go와 성능비교이다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;falcon rest api with gunicorn (-w 9 -k gevent)&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;wrk -t10 -c100 -d30s http://localhost:5000
Running 30s test @ http://localhost:5000
  10 threads and 100 connections
  Thread Stats   Avg      Stdev     Max   +/- Stdev
    Latency   221.79ms  414.03ms   2.00s    85.43%
    Req/Sec   755.94    486.41     2.77k    64.26%
  139452 requests in 30.08s, 32.98MB read
  Socket errors: connect 0, read 0, write 0, timeout 389
Requests/sec:   4636.13
Transfer/sec:      1.10MB
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;sample http server with gogin only&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;wrk -t10 -c100 -d30s http://localhost:8080
Running 30s test @ http://localhost:8080
  10 threads and 100 connections
  Thread Stats   Avg      Stdev     Max   +/- Stdev
    Latency     6.65ms    6.50ms  76.68ms   76.00%
    Req/Sec     1.83k   402.97     5.40k    74.30%
  547412 requests in 30.08s, 92.93MB read
Requests/sec:  18199.96
Transfer/sec:      3.09MB
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;참고로 테스트 하드웨어 장비는 다음과 같다. (구린 내 아이맥ㅠ)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  Model Name:	iMac
  Model Identifier:	iMac11,3
  Processor Name:	Intel Core i5
  Processor Speed:	2.8 GHz
  Number of Processors:	1
  Total Number of Cores:	4
  L2 Cache (per Core):	256 KB
  L3 Cache:	8 MB
  Memory:	12 GB
  Processor Interconnect Speed:	4.8 GT/s
  Boot ROM Version:	IM112.0057.B01
  SMC Version (system):	1.59f2
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>About</title>
      <link>https://ziwon.github.io/about/</link>
      <pubDate>Tue, 01 Sep 2015 07:37:45 +0900</pubDate>
      
      <guid>https://ziwon.github.io/about/</guid>
      <description>&lt;p&gt;Just another developer who is bulding services with &lt;code&gt;go&lt;/code&gt;, &lt;code&gt;python&lt;/code&gt; and &lt;code&gt;java&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;while(stillAlive) {
  // TODO: Traveling the World
  print(&amp;quot;Eat, Sleep and Shit&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;iframe width=&#34;100%&#34; height=&#34;166&#34; scrolling=&#34;no&#34; frameborder=&#34;no&#34; src=&#34;https://w.soundcloud.com/player/?url=https%3A//api.soundcloud.com/tracks/17301025&amp;amp;color=ff5500&amp;amp;auto_play=true&amp;amp;hide_related=false&amp;amp;show_comments=true&amp;amp;show_user=true&amp;amp;show_reposts=false&#34;&gt;&lt;/iframe&gt;
</description>
    </item>
    
    <item>
      <title>Generics of a Higher Kind</title>
      <link>https://ziwon.github.io/posts/generics-of-a-higher-Kind/</link>
      <pubDate>Sat, 30 Aug 2014 17:23:11 +0900</pubDate>
      
      <guid>https://ziwon.github.io/posts/generics-of-a-higher-Kind/</guid>
      <description>

&lt;h2 id=&#34;1-introduction&#34;&gt;1. Introduction&lt;/h2&gt;

&lt;h3 id=&#34;일차-매개변수적-다형성과-고차-타입-생성자-다형성&#34;&gt;일차 매개변수적 다형성과 고차 타입 생성자 다형성&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;일차 매개변수적 다형성은 정적 타입 프로그래밍 언어의 표준 요소임&lt;/li&gt;
&lt;li&gt;일차 매개변수적 다형성은 제네릭(generic)이라고 부름&lt;/li&gt;
&lt;li&gt;제네릭의 한 가지 응용 분야는 콜렉션(collection)

&lt;ul&gt;
&lt;li&gt;예) &lt;code&gt;List[A]&lt;/code&gt; 타입은  주어진 요소 A 타입의 리스트를 표현,  A는 자유롭게 선택됨&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;일차 매개변수적 다형성은 &lt;code&gt;List&lt;/code&gt;와 같은 타입 생성자를 도출하며 타입을 추상화 함&lt;/li&gt;
&lt;li&gt;그러나 결과로 나온 타입 생성자는 그들 자신을 추상화할 수 없음

&lt;ul&gt;
&lt;li&gt;예) &lt;code&gt;List&lt;/code&gt;와 같은 타입 생성자를 다른 타입 생성자의 타입 인자로 전달할 수 없음&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;이런 제한은 자연스러운 추상를 정형화하는데 방해가 되며 불필요한 중복 코드로 이어짐&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;고차-타입-생성자-다형성와-카인드&#34;&gt;고차 타입 생성자 다형성와 카인드&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;고차 타입 생성자 다형성을 통해 더 많은 제네럴티를 확보할 수 있음&lt;/li&gt;
&lt;li&gt;이 논문에서는 Scala 프로그래밍 언어의 타입 생성자 다형성의 설계와 구현에 대해 살펴봄&lt;/li&gt;
&lt;li&gt;Scala 2.5 버전부터 고차 타입 제네릭을 이용할 수 있음&lt;/li&gt;
&lt;li&gt;고차 타입 제네릭에서는 타입과 타입 생성자를 특정 지우기 위해 개발한 카인드 시스템을 사용함&lt;/li&gt;
&lt;li&gt;카인드는 &amp;lsquo;어떤 타입 혹은 타입 생성자가 추상화에서 허용될 수 있는 인스턴스&amp;rsquo; 인지를 표현함&lt;/li&gt;
&lt;li&gt;즉, 카인드의 타입에 대한 역할은 타입이 변수에 대해 하는 역할임&lt;/li&gt;
&lt;li&gt;카인드는 타입이나 타입 생성자의 3가지를 캡쳐함:  쉐이프, 하위/상위 바운드, 변성&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;추상-타입-멤버를-지닌-타입-vs-타입-생성자&#34;&gt;추상 타입 멤버를 지닌 타입 vs 타입 생성자&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;가상 타입이나 가상 클래스를 지닌 언어는 추상 타입 멤버를 통해 타입 생성자 다형성을 코드화할 수 있음, Scala가 이런 부류의 언어에 속함&lt;/li&gt;

&lt;li&gt;&lt;p&gt;예) Scala에서는 타입 매개변수화된 클래스 대신 추상 타입 멤버를 지닌 클래스로 &lt;code&gt;List&lt;/code&gt;를 정의할 수 있음&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;abstract class List { type Elem }
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;List&lt;/code&gt;의 구체적인 구현은 &lt;code&gt;List { type Elem - String }&lt;/code&gt; 처럼 타입 재정의를 통해 모델링할 수 있음&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;결정적인 것은 이렇게 코드화된 &lt;code&gt;List&lt;/code&gt;가 타입 생성자가 아닌 타입이라는 점. 따라서, &lt;code&gt;List&lt;/code&gt;를 일차 다형성의 타입 인자나 추상 타입 인스턴스로 전달할 수 있음&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;타입 생성자 다형성과 비교하면, 이런 코드화는 3가지 단점이 있음&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;첫째, 다소 장황하게 느껴짐&lt;/li&gt;
&lt;li&gt;둘째, 요소 타입을 나타내는 명명된 멤버의 정의가 필요한데, 이는 클래스 상속 계층에서 이름 충돌의 위험을 유발할 수 있음&lt;/li&gt;
&lt;li&gt;셋째, 이런 코드화는 이후 구체적인 변수로 인스턴스화될 수 없는 어떤 무의미한 타입의 추상화를 정의하도록 허용함&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;반대로 타입 생성자 다형성은 카인드 안정성를 지님, 잘 카인드된 타입의 적용하면 무의미한 타입을 만들지 않음&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;이는 객체지향 프로그래밍의 타입 생성자 다형성 포함을 찬성하는 논증의 3가지 이유임&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;2-reducing-code-duplication-with-type-constructor-polymorphism&#34;&gt;2. Reducing Code Duplication with Type Constructor Polymorphism&lt;/h2&gt;

&lt;h3 id=&#34;코드-중복&#34;&gt;코드 중복&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;다음은 Scala의 &lt;code&gt;Iterable[T]&lt;/code&gt; 트레이트의 구현체로 혼합 구성(mixin composition)을 지원하는 추상 클래스임&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;trait Iterable[T] {
    def filter(p: T =&amp;gt; Boolean): Iterable[T]
    def remove(p: T =&amp;gt; Boolean): Iterable[T] = filter (x =&amp;gt; !p(x))
}

trait List[T] extends Iterable[T] {
    def filter(p: T =&amp;gt; Boolean): List[T]
    override def remove(p: T =&amp;gt; Boolean): List[T] = filter (x =&amp;gt; !p(x))
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;Iterable&lt;/code&gt;은 추상 메소드 &lt;code&gt;filter&lt;/code&gt;와 편의 메소드 &lt;code&gt;remove&lt;/code&gt;를 포함&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;하위 클래스는 &lt;code&gt;filter&lt;/code&gt;를 구현해야 현재 콜렉션의 술부 &lt;code&gt;p&lt;/code&gt;를 만족하는 요소를 지닌 콜렉션를 생성할 수 있음&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;remove&lt;/code&gt;는 &lt;code&gt;filter&lt;/code&gt;에 의해 구현되는데, 단순히 술부를 반전한 것임&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;리스트를 필터링할 경우, 리스트를 반환케 될 것을 기대할 수 있음&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;따라서, &lt;code&gt;List&lt;/code&gt;는 자신의 결과 타입을 공변하게 재정의하기 위해 &lt;code&gt;filter&lt;/code&gt;를 오버라이딩해야 함 (세부 구현은 생략)&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;일관성을 위해 &lt;code&gt;remove&lt;/code&gt;는 같은 결과 타입을 지녀야 하는데, 마찬가지로 오버라이딩 하는 거외에는 방법이 없음.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;메소드 모두가 &lt;code&gt;List&lt;/code&gt;에서 반복되므로 코드 중복은 명확함&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;타입-생성자를-통한-해법&#34;&gt;타입 생성자를 통한 해법&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;해법은 &lt;code&gt;filter&lt;/code&gt;와 &lt;code&gt;remove&lt;/code&gt;의 결과 컨테이너를 나타내는 타입 생성자로 추상화하는 것임&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;trait iterable[T, Container[X]] {
    def filter(p: T =&amp;gt; Boolean): Container[T]
    def remove(p: T =&amp;gt; Boolean): Container[T] = filter (x =&amp;gt; !p(x))
}

trait List[T] extends Iterable[T, List]
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;개선된 &lt;code&gt;Iterable&lt;/code&gt;은 두 개의 타입 매개변수를 취함: &lt;code&gt;[T, Container[X]]&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;첫 번째 &lt;code&gt;T&lt;/code&gt;는 자신의 요소 타입을 나타내고, 두 번째 &lt;code&gt;Container&lt;/code&gt;는 &lt;code&gt;filter&lt;/code&gt;와 &lt;code&gt;remove&lt;/code&gt; 메소드의 결과 타입을 결정하는 타입 생성자임&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;Container&lt;/code&gt;는 타입 매개변수 하나를 취함&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;2-1-type-constructors-and-kinds&#34;&gt;2.1 Type constructors and kinds&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;타입 생성자와 적당한 타입을 구별하기 위해 카인드(kind, 함수형 프로그래밍에서 차용한 용어)를 사용함&lt;/li&gt;

&lt;li&gt;&lt;p&gt;카인드는 변수에 대한 타입처럼 타입에 대한 것임, 이는 3가지 레벨로 언어를 구성함&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;객체는 타입으로 분류되고, 타입은 카인드로 분류됨&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;타입과 달리, 카인드는 순수하게 구조적임: 타입에 기대되는 타입의 매개변수의 종류를 반영함&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;적합한 타입들은 모두 타입 매개변수의 수가 같으므로 동일한 카인드 &lt;code&gt;*&lt;/code&gt;로 분류됨&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;타입 생성자를 분류하기 위해, 카인드 생성자 &lt;code&gt;From → To&lt;/code&gt;를 사용함&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;From&lt;/code&gt;은 기대되는 타입 인자의 카인드이며 &lt;code&gt;To&lt;/code&gt;는 인자에 타입 생성자를 적용할 때의 결과 타입의 카인드임&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;예) &lt;code&gt;class List[T]&lt;/code&gt;는 적합한 타입을 도출하는 적합한 타입에 대해 적용하며 &lt;code&gt;* → *&lt;/code&gt;로 분류되는 &lt;code&gt;List&lt;/code&gt; 타입 생성자로 이루어 짐&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;카인드 레벨의 초기 모델은 다음과 같은 문법으로 기술됨&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;K ::= * | K  → K
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;타입 생성자 다형성없이 언어 타입의 정형성(well-formedness)을 정의하는 규칙은 타입에 할당하는 카인드 규칙과 일치함&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;이 규칙을 타입이 변수와 표현식에 타입 체킹을 하는 것처럼 카인드 체킹으로 일반화하여 확장시킴&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;클래스나 언바운드 타입 매개변수 혹은 추상 타입 멤버는 하나의 K&amp;rsquo;  카인드의 타입 매개변수가 있을 경우 , K&amp;rsquo; → * 인 카인드를 받음&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;바운드 타입 매개변수나 추상 멤버는 K&amp;rsquo; → K인 카인드를 할당받음, 이 때 K는 바운드 타입과 일치함&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;타입-커링&#34;&gt;타입 커링&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;다중 타입 매개변수를 다루기 위해 이 스킴을 일반화하는데 커링을 사용함&lt;/li&gt;
&lt;li&gt;T[T&amp;rsquo;] 타입을 적용하면 T가 K&amp;rsquo; → K인 카인드를 가지며 T&amp;rsquo;가 K&amp;rsquo; 카인드로 분류될 때, K인 카인드를 지님&lt;/li&gt;
&lt;li&gt;타입 생성자 다형성으로 인한 Scala 확장의 문법적인 영향은 마이너함&lt;/li&gt;
&lt;li&gt;클래스와 타입 알리어스만 형식적인 타입 매개변수를 선언할 수 있었으나 타입 매개변수와 추상 멤버 타입을 포함하기 위해 확장됨&lt;/li&gt;

&lt;li&gt;&lt;p&gt;다음은 추상 타입 생성자 멤버를 사용한 선택적인 형태임&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;trait Iterable[T] {
    type Container[X]

    def filter(p: T =&amp;gt; Boolean): Container[T]
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;2-2-improving-iterable&#34;&gt;2.2 Improving Iterable&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;타입 생성자 다형성은 설계 제약사항을 표현하는 데 필수적인 역할을 함&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Iterable의 map, filter, flatMap의 시그너쳐과 구현에 대해 논의함&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;map은 요소를 그 함수에 의해 지정된 요소로 변환함&lt;/li&gt;
&lt;li&gt;filter는 술부인 함수를 해석해서 이를 만족하는 요소만 유지함&lt;/li&gt;
&lt;li&gt;flatMap은 주어진 함수를 적용, 원본 콜렉션의 모든 요소에 대해 요소의 콜렉션을 만들고, 이런 콜렉션 내의 요소들을 수집해서 한 콜렉션으로 만듦 (&lt;a href=&#34;https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/flatMap.png&#34;&gt;참고&lt;/a&gt;)
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;다음은 콜렉션의 반복을 캡슐화한 잘 알려진 Iterator 추상과 쌍으로 고려되는 Builder 추상임&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;trait Builder[Container[X], T] {
    def +=(el: T): Unit
    def finalise(): Container[T]
}

trait Iterator[T] {
    def next() : T
    def hasNext: Boolean

    def foreach(op: T =&amp;gt; Unit): Unit = while(hasNext) op(next())
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Builder는 빌드하는 콜렉션을 나타내는 타입 생성자를 추상화함&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;+=&lt;/code&gt;  메소드는 콜렉션에 나타나야 하는 순서로 요소를 공급하는데 사용됨&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;콜렉션 자체는 &lt;code&gt;finalize&lt;/code&gt;에 반환됨&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;예) &lt;code&gt;Builder[List, Int]&lt;/code&gt;는 &lt;code&gt;ListBuffer[Int]&lt;/code&gt;로 생각할 수 있고, 이들 모두 &lt;code&gt;List[Int]&lt;/code&gt;를 만드는데 사용될 수 있음&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;다음은 mapTo/fiilterTo/flatMapTo가 어떻게 좀 더 유연하게 구현될 수 있는지 나타냄&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;trait Buildable[Context[X]] {
    def build[T]: Builder[Container, T]
}

trait Iterable[T] {
    type Container[X] &amp;lt;: Iterable[X]

    def elements: Iterator[T]

    def mapTo[U, C[X]](f: T =&amp;gt; U)(b: Buildable[C]): C[U] = {
        val buff = b.build[T]
        val elems = elements

        while(elems.hasNext) {
            val el = elems.next
            if(p(el)) buff += el
        }

        buff.finalise()
    }

    def filterTo[C[X]](p: T =&amp;gt; Boolean)(b: Buildable[C]): C[T] = {
        val buff = b.build[T]
        val elems = elements

        while(elems.hasNext) {
            val el = elems.next
            if(p(el)) buff += el
        }

        buff.finalize()
    }

    def flatMapTo[U, C[X]] (f: T =&amp;gt; Iterable[U])(b: Buildable[C]): C[U] = {
        val buff = b.build[U]
        val elems = elements

        while(elems.hasNext) {
            f(elems.next).elements.foreach{ el =&amp;gt; buff += el }
        }

        buff.finalize()
    }

    def map[U](f: T =&amp;gt; U)(b: Buildable[Container]): Container[U] = 
        mapTo[U, Container](f)(b)

    def filter(p: T =&amp;gt; Boolean)(b: Buildable[Container]):Container[T] = 
        filterTo[Container](p)(b)

    def flatMap[U](f: T =&amp;gt; Container[U])(b: Buildable[Container]): Container[U] = 
        flatMapTo[U, Container](f)(b)
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;만들어진 콜렉션과 원본 콜렉션을 디커플링하는 것으로 제네릭화 함 - 이들은 같을 필요가 없음&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;콜렉션을 반복하는 것과 콜렉션을 만드는 것은 서로 직교함 (의역: 연관성이 없음)&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;즉, 콜렉션의 요소를 반복하기 위해 콜렉션을 빌드할 수 있어야 할 필요는 없음&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;mapTo와 같은 좀 더 복잡한 연산의 경우, &lt;code&gt;Buildable[C]&lt;/code&gt;의 인스턴스가 필요함&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;따라서, 콜렉션 C를 빌드하는 Iterable의 메소드는 &lt;code&gt;Buildable[C]&lt;/code&gt; 타입의 추가 매개변수를 취함&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;섹션 3에서 Scala의 직교적인(orthogonal) 특징이 이 매개변수의 실제 인자를 공급하는데 있어 콜러(caller)를 어떻게 해방시키는지 살펴볼 것임&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;용어&#34;&gt;용어&lt;/h3&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;국문&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;영문&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;일차 매개변수적 다형성&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;First-order parametric Polymorphism&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;타입 생성자&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Type Constructor&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;타입 생성자 다형성&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Type Constructor Polymorphism&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;타입 매개변수화 클래스&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Type Parametised Class&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;제네럴티&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Generality&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;카인드&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Kind&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;추상 타입 멤버&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Abstract Type Member&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;카인드 안정성&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Kind soundness&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
</description>
    </item>
    
    <item>
      <title>Principles of Reactive Programming</title>
      <link>https://ziwon.github.io/posts/principles-of-reactive-programming/</link>
      <pubDate>Wed, 22 Jan 2014 11:15:43 +0900</pubDate>
      
      <guid>https://ziwon.github.io/posts/principles-of-reactive-programming/</guid>
      <description>&lt;p&gt;Finally got my certificate for the Coursera &amp;ldquo;Principles of Reactive Programming&amp;rdquo; course. :)
It was rather easy in the beginning, but became more challenging as it
went on. Now where to go?&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;../../coursera_reactive_2014.jpg&#34;/&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Lambda Calculus</title>
      <link>https://ziwon.github.io/posts/lambda-calculus/</link>
      <pubDate>Tue, 22 Oct 2013 13:03:05 +0900</pubDate>
      
      <guid>https://ziwon.github.io/posts/lambda-calculus/</guid>
      <description>

&lt;p&gt;람다 대수는 결정문제(decision problem)를 풀기 위해, 계산가능성(computability)의 개념을 정의한 수학적 모델로 1936년 &lt;a href=&#34;http://en.wikipedia.org/wiki/Alonzo_Church&#34;&gt;알로존 처치&lt;/a&gt;(Alonzo Church)가 고안하였다.&lt;/p&gt;

&lt;p&gt;좀 더 구체적으로는 소프트웨어에서 &amp;lsquo;알고리즘이란 무엇인가?&amp;lsquo;를 정의한 클래스(class)나 객체(object)가 아닌 값(function) 중심 언어, 즉 함수형 언어의 계산 모델이다. (같은 해에 처치의 제자였던, &lt;a href=&#34;http://en.wikipedia.org/wiki/Alan_Turing&#34;&gt;앨런 튜닝&lt;/a&gt;은 튜링 머신의 개념으로 계산 모델을  정의했다. Lisp를 만든 &lt;a href=&#34;http://en.wikipedia.org/wiki/John_McCarthy_(computer_scientist))도 처치의 제자였다고 한다.&#34;&gt;존 매카시&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://upload.wikimedia.org/wikipedia/en/thumb/a/a6/Alonzo_Church.jpg/220px-Alonzo_Church.jpg&#34; alt=&#34;&#39;알론조 처치&#39;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;람다 대수는 그 자체가 이미 하나의 언어로 많은 함수형 프로그래밍 언어가 람다대수에 기초하고 있다.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;functional language = lambda calcus + sugars (ex. Lisp, ML, Haskell, Scala.. ) [&lt;a href=&#34;http://ropas.snu.ac.kr/~dreameye/PL/slide/PL7.pdf&#34; title=&#34;dreameye님의 람다계산법&#34;&gt;1&lt;/a&gt;]&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;즉, 우리가 함수를 정의하고 전달하고 반환하는 모든 것들이 람다 대수의 원리를 따르는 계산인 것이다.&lt;/p&gt;

&lt;p&gt;이상 아래의 내용은 &amp;ldquo;A Tutorial Introduction to the Lambda Calculus[&lt;a href=&#34;http://www.inf.fu-berlin.de/lehre/WS03/alpi/lambda.pdf&#34; title=&#34;A Tutorial Introduction to the Lambda Calculus&#34;&gt;2&lt;/a&gt;]&amp;ldquo;의 내용 중 일부를 중심으로. 필요한 경우 살을 붙여가며, 간략히 요약한 것이다.&lt;/p&gt;

&lt;h3 id=&#34;람다표현식-expression&#34;&gt;람다표현식 (expression)&lt;/h3&gt;

&lt;p&gt;람다 대수에서는 모든 계산 가능한 함수를 람다로 표현할 수 있는데, 람다 표현식(λ expression)은 다음과 같이 재귀적으로 정의된다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;expression&amp;gt;  := &amp;lt;name&amp;gt; | &amp;lt;function&amp;gt; | &amp;lt;application&amp;gt;
&amp;lt;function&amp;gt;    := λ&amp;lt;name&amp;gt;.&amp;lt;expression&amp;gt;
&amp;lt;application&amp;gt; := &amp;lt;expression&amp;gt; &amp;lt;expression&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;위에서 보다시피, 표현식(expression)은 사상점을 식별하는 변수나 혹은 함수 본문을 정의하고 있는 사상(abstraction)이거나 사상을 특화하는 적용(application)으로 구성된다.&lt;/p&gt;

&lt;p&gt;람다 대수에서 키워드는 \(λ\) 와 \(.\)이다. 표현식을 분명하게 표기하기 위해 괄호를 사용한다. 예를 들어, 표현식 \(E\)는 \((E)\)와 동일하다. 혼란을 피하기 위해 함수의 적용(application)은 왼쪽으로 결합한다. 따라서, 표현식 $$E_1E_2E_3&amp;hellip;E_n$$ 은 아래와 같이 표현식을 적용하며 평가된다. $$(&amp;hellip;((E_1E_2)E_3)&amp;hellip;E_n)$$&lt;/p&gt;

&lt;p&gt;예를 들면, 함수 \(f(x) = x\)은 람다식으로 다음과 같다.&lt;/p&gt;

&lt;p&gt;$$λx.x$$&lt;/p&gt;

&lt;p&gt;위 표현식은 항등함수(identity function)를 정의한다. &lt;code&gt;λ&lt;/code&gt; 표기 다음의 이름은 이 함수 인자의 식별자라 하고, &lt;code&gt;.&lt;/code&gt; 표기 다음의 표현식을 함수 정의의 본문(body)이라고 한다.&lt;/p&gt;

&lt;p&gt;함수는 표현식에 적용될 수 있다. 적용(application)의 예는 다음과 같다.&lt;/p&gt;

&lt;p&gt;$$(λx.x)y$$&lt;/p&gt;

&lt;p&gt;이는 &lt;code&gt;y&lt;/code&gt;에 적용된 항등함수이다. 함수 적용은 함수를 정의하는 본문 안에서 인자의 값 &lt;code&gt;x&lt;/code&gt;를 치환함으로써 (여기서는 &lt;code&gt;y&lt;/code&gt;로) 평가된다. 예를 들면, 다음과 같다.&lt;/p&gt;

&lt;p&gt;$$(λx.x)y = [y/x]x = y$$&lt;/p&gt;

&lt;p&gt;위 변환에서 &lt;code&gt;[y/x]&lt;/code&gt; 표기는 표현식에서 모든 경우의 &lt;code&gt;x&lt;/code&gt;가 &lt;code&gt;y&lt;/code&gt;에 의해 오른쪽으로 치환되는 것을 나타낸다. 그리고, 람다식에서 람다 식별자인 이름은 단순한 플레이스홀더에 지나지 않는다. 따라서, 다음은 동등하다.&lt;/p&gt;

&lt;p&gt;$$(λz.z) ≡ (λy.y) ≡ (λt.t) ≡ (λu.u)$$&lt;/p&gt;

&lt;h3 id=&#34;자유-변수와-종속-변수-free-variable-and-bound-variable&#34;&gt;자유 변수와 종속 변수 (free variable and bound variable)&lt;/h3&gt;

&lt;p&gt;람다 대수에서 사상(abstraction)의 정의에 해당하는 모든 이름은 지역(local)이다. 함수 $λx.x$에서 &lt;code&gt;x&lt;/code&gt;는 &lt;code&gt;x&lt;/code&gt;로 시작하는 정의의 본문 안에 나타나므로 &amp;ldquo;종속된다&amp;rdquo;라고 말한다. &lt;code&gt;λ&lt;/code&gt;로 시작하지 않는 이름을 자유 변수(free variable), 또는 비지역(non-local)이라고 일컫는다.&lt;/p&gt;

&lt;p&gt;예를 들면, 아래의 표현식에서 $$(λx.xy)$$ 에서 변수 &lt;code&gt;x&lt;/code&gt;는 종속되나 &lt;code&gt;y&lt;/code&gt;는 자유롭다. 아래의 표현식에서, $$(λx.x)(λy.yx)$$ &lt;code&gt;x&lt;/code&gt;는 왼쪽에서 첫째 표현식의 본문에서는 첫번째 &lt;code&gt;λ&lt;/code&gt;에 종속된다. 두 번째 표현식의 본문에서 &lt;code&gt;y&lt;/code&gt;는 두 번째 &lt;code&gt;y&lt;/code&gt;에 종속되나 &lt;code&gt;x&lt;/code&gt;는 자유롭다. 두 번째 표현식의 &lt;code&gt;x&lt;/code&gt;가 첫 번째 표현식의 &lt;code&gt;x&lt;/code&gt;에 대해서 완전히 독립적이라는 것은 매우 중요하다.&lt;/p&gt;

&lt;p&gt;표현식에서 변수 &lt;code&gt;&amp;lt;name&amp;gt;&lt;/code&gt;이 다음의 3가지 경우에 해당할 때, 자유 변수라고 한다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;name&amp;gt;&lt;/code&gt;은 &lt;code&gt;&amp;lt;name&amp;gt;&lt;/code&gt;의 자유 변수이다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;name&amp;gt;&lt;/code&gt;은 &lt;code&gt;λ&amp;lt;name1&amp;gt;&lt;/code&gt;의 자유 변수이다. (단, 식별자 &lt;code&gt;&amp;lt;name&amp;gt;&lt;/code&gt;이 &lt;code&gt;&amp;lt;name1&amp;gt;&lt;/code&gt;과 다른 &lt;code&gt;&amp;lt;exp&amp;gt;&lt;/code&gt;이고, &lt;code&gt;&amp;lt;name&amp;gt;&lt;/code&gt;이 &lt;code&gt;&amp;lt;exp&amp;gt;&lt;/code&gt;의 자유 변수일 때)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;name&amp;gt;&lt;/code&gt;은 &lt;code&gt;E1E2&lt;/code&gt;의 자유 변수이다. (단, &lt;code&gt;E1&lt;/code&gt;의 자유 변수이거나 혹은 &lt;code&gt;E2&lt;/code&gt;의 자유 변수일때)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;그리고 다음의 두 가지 경우에 한해서 &lt;code&gt;&amp;lt;name&amp;gt;&lt;/code&gt; 변수를 종속 변수라고 한다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;name&amp;gt;&lt;/code&gt;은 &lt;code&gt;λ&amp;lt;name1&amp;gt;&lt;/code&gt;의 종속 변수이다. (단, 식별자 &lt;code&gt;&amp;lt;name&amp;gt;&lt;/code&gt;이 &lt;code&gt;&amp;lt;name1&amp;gt;&lt;/code&gt;과 같고 &lt;code&gt;&amp;lt;exp&amp;gt;&lt;/code&gt;이고, &lt;code&gt;&amp;lt;name&amp;gt;&lt;/code&gt;이 &lt;code&gt;&amp;lt;exp&amp;gt;&lt;/code&gt;의 종속 변수일 때)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;name&amp;gt;&lt;/code&gt;은 &lt;code&gt;E1E2&lt;/code&gt;의 종속 변수이다. (단, &lt;code&gt;E1&lt;/code&gt;의 종속 변수이거나 혹은 &lt;code&gt;E2&lt;/code&gt;의 종속 변수일때)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;이를 수식화하면, 람다 표현식 &lt;code&gt;E&lt;/code&gt;의 자유 변수 집합 &lt;code&gt;M&lt;/code&gt;은 &lt;code&gt;FV(M)&lt;/code&gt;으로 다음과 같다.&lt;/p&gt;

&lt;p&gt;$$FV(x) = {x}$$
$$FV (λx.E) = FV (E)\space/\space{x}$$
$$FV(E1 E2) = FV(E1)∪FV(E2)$$&lt;/p&gt;

&lt;p&gt;한 표현식에서 동일한 식별자가 자유 변수와 종속 변수가 될 수 있음을 주의해야 한다. 아래의 표현식에서,&lt;/p&gt;

&lt;p&gt;$$ (λx.xy)(λy.y) $$&lt;/p&gt;

&lt;p&gt;첫 번째 &lt;code&gt;y&lt;/code&gt;는 왼쪽 방향의 괄호로 묶인 하위 표현식에서는 자유 변수이다. 그러나 오른쪽 방향의 하위 표현식에서는 종속 변수이다.&lt;/p&gt;

&lt;p&gt;자유 변수가 없는 표현식을 닫혀 있다(closed)라고 한다. 닫힌 람다 표현식(Closed lambda expression)을 컴비네이터(combinator)라고도 한다.&lt;/p&gt;

&lt;h3 id=&#34;치환-substitutions&#34;&gt;치환 (Substitutions)&lt;/h3&gt;

&lt;p&gt;함수를 적용할 때마다, 전체 함수 정의를 쓰고 다음에 이를 평가한다. 그러나 단순하게 표기하기 위해 대문자, 숫자 그리고 어떤 함수 정의와 동치로 기호를 사용한다. 예를 들면, 항등함수는 {% m %} (λx.x) {% em %}의 동치로 {% m %} I {% em %} 기호로 표기한다.&lt;/p&gt;

&lt;p&gt;자신에 적용된 항등 함수의 적용은 다음과 같다.&lt;/p&gt;

&lt;p&gt;$$ II ≡ (λx.x)(λx.x) $$&lt;/p&gt;

&lt;p&gt;이 표현식에서 괄호로 묶인 첫 번째 표현식의 본문에 있는 첫 번째 &lt;code&gt;x&lt;/code&gt;는 두 번째 표현식 본문의 &lt;code&gt;x&lt;/code&gt;와 별개의 것이다. 사실, 우리는 위 표현식을 아래와 같이 쓸 수 있다.&lt;/p&gt;

&lt;p&gt;$$ II ≡ (λx.x)(λz.z) $$&lt;/p&gt;

&lt;p&gt;그러므로, 자신에 적용된 항등 함수&lt;/p&gt;

&lt;p&gt;$$ II ≡ (λx.x)(λz.z) $$&lt;/p&gt;

&lt;p&gt;는 다음의 결과를 따르게 된다.&lt;/p&gt;

&lt;p&gt;$$ [λz.z/x]x = λz.z ≡ I $$&lt;/p&gt;

&lt;p&gt;즉, 또 항등함수이다.&lt;/p&gt;

&lt;p&gt;치환을 수행할 때는 식별자의 자유 변수 사건이 종속 변수 사건과 뒤섞이지 않도록 주의해야 한다. 다음 표현식에서&lt;/p&gt;

&lt;p&gt;$$ (λx.(λy.xy))y $$&lt;/p&gt;

&lt;p&gt;(괄호 밖의) 오른쪽 &lt;code&gt;y&lt;/code&gt;는 자유 변수인 반면, 왼쪽에 있는 함수의 &lt;code&gt;y&lt;/code&gt;는 종속 변수이다. 부정확한 치환으로 두 식별자를 합치면 잘못된 결과를 얻는다.&lt;/p&gt;

&lt;p&gt;$$ (λy.yy) $$&lt;/p&gt;

&lt;p&gt;단순히 종속 변수 &lt;code&gt;y&lt;/code&gt;를 &lt;code&gt;t&lt;/code&gt;로 변경하면, 정확한 치환에 의해 완전히 다른 결과를 얻는다.&lt;/p&gt;

&lt;p&gt;$$ (λx.(λt.xt))y = (λt.yt) $$&lt;/p&gt;

&lt;p&gt;&lt;code&gt;E&lt;/code&gt;를 함수 &lt;code&gt;λx.&amp;lt;exp&amp;gt;&lt;/code&gt;에 적용할 경우, &lt;code&gt;&amp;lt;exp&amp;gt;&lt;/code&gt;의 모든 자유 변수 &lt;code&gt;x&lt;/code&gt;는 &lt;code&gt;E&lt;/code&gt;로 치환한다. 표현식에서 종속변수가 &lt;code&gt;E&lt;/code&gt;의 자유변수로 치환될 경우, 치환하기 전에 종속 변수를 새이름으로 변경한다. 예를 들면, 아래의 표현식에서&lt;/p&gt;

&lt;p&gt;$$ (λx.(λy.(x(λx.xy))))y $$&lt;/p&gt;

&lt;p&gt;인자 &lt;code&gt;x&lt;/code&gt;는 &lt;code&gt;y&lt;/code&gt;로 결합시키는데, 함수 본문에서는 첫 번째 &lt;code&gt;x&lt;/code&gt;만이 자유 변수이고 치환될 수 있다. 그래도 치환을 하기 전에 변수 &lt;code&gt;y&lt;/code&gt;의 종속 변수가 자유 변수의 경우와 섞이지 않도록 이름을 변경하자.&lt;/p&gt;

&lt;p&gt;$$ [y/x]λt.(x(λx.xt))) = (λt.(y(λx.xt))) $$&lt;/p&gt;

&lt;h3 id=&#34;call-by-value-call-by-name-call-by-need&#34;&gt;call by value, call by name, call by need&lt;/h3&gt;

&lt;p&gt;표현식을 평가할 때, 안쪽에서 바깥쪽으로 평가하는 전략을 &lt;strong&gt;Application order&lt;/strong&gt; 라고 하며, &lt;strong&gt;call by value&lt;/strong&gt; 이라고 알려져 있다. 예를 들면, 다음과 같다.&lt;/p&gt;

&lt;p&gt;$$ (λx.x^2(λx.(x+2)\space2))) → (λx.x^2(2+2)) → (λx.x^2(4)) → 4^2 → 16 $$&lt;/p&gt;

&lt;p&gt;반면에, 바깥쪽에서 안쪽으로 평가하는 전략을 &lt;strong&gt;Normal order&lt;/strong&gt; 라고 하며 이는 &lt;strong&gt;call by name&lt;/strong&gt; 이라고 알려져 있다. 예를 들면, 다음과 같다.&lt;/p&gt;

&lt;p&gt;$$ (λx.x^2(λx.(x+2)\space2)) → (λx.(x+2)\space2)^2 → (2+2)^2 → 4^2 → 16 $$&lt;/p&gt;

&lt;p&gt;위에서 보다시피, Normal order는 인자의 평가를 필요할 때까지 지연시키기 때문에 Normal order를 &lt;strong&gt;지연 평가(lazy evaluation)&lt;/strong&gt; 라고 부른다. (※. SICP 참고[&lt;a href=&#34;http://mitpress.mit.edu/sicp/full-text/sicp/book/node85.html&#34;&gt;3&lt;/a&gt;])&lt;/p&gt;

&lt;p&gt;위키 정의를 따르면, ** call by need ** 은 아래와 같이 call by name의 최적화된 형태이다. 매번 call by name이 발생할 경우, 함수 본문은 동일하기 때문에 매번 평가할 필요가 없다. 따라서, call by need 에서는 중복적인 연산을 피하기 위해 cache 형태로 값을 저장하여 최초에 한번만 평가한다.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Call-by-need is a memoized version of call-by-name where, if the function argument is evaluated, that value is stored for subsequent uses [&lt;a href=&#34;http://en.wikipedia.org/wiki/Evaluation_strategy#Call_by_need&#34;&gt;4&lt;/a&gt;]&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&#34;lazy-evaluation&#34;&gt;Lazy evaluation&lt;/h4&gt;

&lt;p&gt;어떨 때는 *lazy*를 call by name과 call by need를 모두 지칭하지만, 어떨 때는 call by need만을 지칭하기도 한다. 특히, Haskell에서 Lazy evaluation은 기술적으로 non-strict와 sharing, 즉 call by need를 뜻한다.[&lt;a href=&#34;http://www.haskell.org/haskellwiki/Lazy_evaluation&#34;&gt;5&lt;/a&gt;]&lt;/p&gt;

&lt;p&gt;이러한 충돌은 논문에서도 살펴볼 수 있다. 어떤 이는 call by name을 &lt;code&gt;lazy&lt;/code&gt;라고, 어떤 이는 call by need를 &lt;code&gt;lazy&lt;/code&gt;라고 지칭한다.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;예를 들면, Abramsky의 논문 &amp;lsquo;The Lazy Lambda Calculus (1990)&amp;lsquo;에서는 &amp;lsquo;call by name&amp;rsquo;을 &amp;lsquo;lazy&amp;rsquo;라고 칭하고 있다. 반면에, Odersky 교수가 참여한 논문 &amp;lsquo;A Call-By-Need Lambda Calculus (1995)&amp;lsquo;에서는 Abramsky의 논문에서의 &amp;lsquo;lazy&amp;rsquo;라는 표현과 충돌을 피하기 위해 &amp;lsquo;call by need&amp;rsquo;라고 표현하고 있다. [&lt;a href=&#34;http://lampwww.epfl.ch/~odersky/papers/popl95.ps.gz&#34; title=&#34;A Call-By-Need Lambda Calculus&#34;&gt;6&lt;/a&gt;]&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Odersky 논문에서 보듯, 람다 대수를 이용한 프로그래밍 언어에 있어 &amp;lsquo;call by need&amp;rsquo;는 컴파일러 성능과 직결된 중요한 기능이기 때문에 lazy evaluation을 sharing, caching, memoziation 등의 최적화 기법과 연관짓게 된다. 그러나, 일반적으로 표현식이 그 값이 필요할 때까지 평가되지 않는 것을 &amp;lsquo;lazy evaluation&amp;rsquo; 이라고 말하므로 call by name과 call by need 모두 이에 해당한다.&lt;/p&gt;

&lt;p&gt;중요한 것은 call by value, call by name, call by need의 차이를 아는 것이다.&lt;/p&gt;

&lt;h3 id=&#34;산술-arithmetic&#34;&gt;산술 (Arithmetic)&lt;/h3&gt;

&lt;p&gt;우리는 프로그래밍 언어에서 산술적인 계산을 할 수 있어야 한다고 기대한다. 람다 대수에서 숫자는 &lt;code&gt;zero&lt;/code&gt;에서 시작해서 &lt;code&gt;suc(zero)&lt;/code&gt;라 쓰고 1을, &lt;code&gt;suc(suc(zeo))&lt;/code&gt;라 쓰고 2를, 그리고 기타등등 이런 식으로 표현한다.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;zero&lt;/code&gt;는 다음과 같이 정의될 수 있다.&lt;/p&gt;

&lt;p&gt;$$ λs.(λz.z) $$&lt;/p&gt;

&lt;p&gt;이는 &lt;code&gt;s&lt;/code&gt;와 &lt;code&gt;z&lt;/code&gt; 두 개의 인자를 지닌 함수이다. 하나 이상의 인자를 지닌 표현식을 다음과 같이 축약한다.&lt;/p&gt;

&lt;p&gt;$$ λsz.z $$&lt;/p&gt;

&lt;p&gt;즉, &lt;code&gt;s&lt;/code&gt;는 평가시 치환되는 첫 번째 인자이고, &lt;code&gt;z&lt;/code&gt;는 두 번째 인자이다. 이 표기를 사용해 자연수는 다음과 같이 정의된다.&lt;/p&gt;

&lt;p&gt;$$ 1 ≡ λsz.s(z) $$
$$ 2 ≡ λsz.s(s(z)) $$
$$ 3 ≡ λsz.s(s(s(z))) $$&lt;/p&gt;

&lt;p&gt;따라서, 처치의 자연수는 &lt;code&gt;n&lt;/code&gt;에 대응되는 함수를 &lt;code&gt;n&lt;/code&gt;회 반복해서 실행한다.&lt;/p&gt;

&lt;p&gt;$$ n ≡ λsz.s^n(z) $$&lt;/p&gt;

&lt;p&gt;흥미로운 것은 계승자 함수이다. &lt;code&gt;y&lt;/code&gt;의 추가적인 적용으로 자연수 &lt;code&gt;y&lt;/code&gt;를 입력받아 &lt;code&gt;y + 1&lt;/code&gt;을 반환하는 계승자 함수(successor)를 다음과 같이 정의할 수 있다.&lt;/p&gt;

&lt;p&gt;$$ S ≡ λwyx.y(wyx) $$&lt;/p&gt;

&lt;p&gt;계승자 함수에 &lt;code&gt;zero&lt;/code&gt;를 적용하면, 다음을 도출한다.&lt;/p&gt;

&lt;p&gt;$$ S0 ≡ (λwyx.y(wyx))(λsz.z) $$&lt;/p&gt;

&lt;p&gt;첫 번째 표현식 본문에 &lt;code&gt;w&lt;/code&gt;를 &lt;code&gt;(λsz.z)&lt;/code&gt;로 치환하면 자연수 1에 대응된다.&lt;/p&gt;

&lt;p&gt;$$ λyx.y((λsz.z)yx) = λyx.y((λz.z)x) = λyx.y(x) ≡ 1 $$&lt;/p&gt;

&lt;p&gt;계승자 함수에 &lt;code&gt;1&lt;/code&gt;를 적용하면, 자연수 2에 대응된다.&lt;/p&gt;

&lt;p&gt;$$ S1 ≡ (λwyx.y(wyx))(λsz.s(z)) = λyx.y((λsz.s(z))yx) = λyx.y(y(x)) ≡ 2 $$&lt;/p&gt;

&lt;p&gt;(이하 중략)&lt;/p&gt;

&lt;p&gt;이상, 람다 대수로 자연수와 그 연산을 표현하는 것을 처치 부호화(Church encoding)라고 한다.[&lt;a href=&#34;http://en.wikipedia.org/wiki/Church_encoding&#34; title=&#34;Church encoding&#34;&gt;7&lt;/a&gt;]&lt;/p&gt;

&lt;h3 id=&#34;결론&#34;&gt;결론&lt;/h3&gt;

&lt;p&gt;이상, 람다계산법에 대해 간략히 살펴보았다. 짧게나마 살펴보니, 람다계산법을 공부할수록 쉽게 함수형 프로그래밍의 원리를 이해할 수 있을 것 같다.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>