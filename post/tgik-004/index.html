<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"  lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1"/>

<title>TGI Kubernetes 004: RBAC | ziwon.github.io</title>



<link href="https://ziwon.github.io/index.xml" rel="alternate" type="application/rss+xml" title="ziwon.github.io" />
<link rel='stylesheet' href='https://ziwon.github.io/css/style-kiss.css'><link rel='stylesheet' href='https://ziwon.github.io/css/custom.css'><link rel='stylesheet' href='https://ziwon.github.io/css/syntax-github.css'><link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">


<link rel="apple-touch-icon" sizes="57x57" href="/apple-icon-57x57.png">
<link rel="apple-touch-icon" sizes="60x60" href="/apple-icon-60x60.png">
<link rel="apple-touch-icon" sizes="72x72" href="/apple-icon-72x72.png">
<link rel="apple-touch-icon" sizes="76x76" href="/apple-icon-76x76.png">
<link rel="apple-touch-icon" sizes="114x114" href="/apple-icon-114x114.png">
<link rel="apple-touch-icon" sizes="120x120" href="/apple-icon-120x120.png">
<link rel="apple-touch-icon" sizes="144x144" href="/apple-icon-144x144.png">
<link rel="apple-touch-icon" sizes="152x152" href="/apple-icon-152x152.png">
<link rel="apple-touch-icon" sizes="180x180" href="/apple-icon-180x180.png">
<link rel="icon" type="image/png" sizes="192x192"  href="/android-icon-192x192.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="96x96" href="/favicon-96x96.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<meta name="msapplication-TileImage" content="/ms-icon-144x144.png">



<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css">


<script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.9/highlight.min.js"></script>
<script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.9/languages/bash.min.js"></script>
<script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.9/languages/go.min.js"></script>
<script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.9/languages/rust.min.js"></script>
<script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.9/languages/scala.min.js"></script>
<script>hljs.initHighlightingOnLoad();</script>


<script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML"></script>

<meta name="msapplication-TileColor" content="#da532c">
<meta name="theme-color" content="#ffffff">
</head>
<body>

<section class="section">
  <div class="container">
    <nav id="nav-main" class="nav">
      <div id="nav-name" class="nav-left">
        <a id="nav-anchor" class="nav-item" href="https://ziwon.github.io/">
          <h1 id="nav-heading" class="title is-4">ziwon.github.io</h1>
        </a>
      </div>
      <div class="nav-right">
        <nav id="nav-items" class="nav-item level is-mobile"><a class="level-item" aria-label="twitter" href='https://twitter.com/theluno'
            target='_blank' rel='noopener'>
            <span class="icon">
              <i class><svg viewbox='0 0 24 24' stroke-linecap='round' stroke-linejoin='round' stroke-width='2' aria-hidden='true'>
    
    <path d="M23 3a10.9 10.9 0 0 1-3.14 1.53 4.48 4.48 0 0 0-7.86 3v1A10.66 10.66 0 0 1 3 4s-4 9 5 13a11.64 11.64 0 0 1-7 2c9 5 20 0 20-11.5a4.5 4.5 0 0 0-.08-.83A7.72 7.72 0 0 0 23 3z"/>
    
  </svg></i>
            </span>
          </a><a class="level-item" aria-label="github" href='https://github.com/ziwon'
            target='_blank' rel='noopener'>
            <span class="icon">
              <i class><svg viewbox='0 0 24 24' stroke-linecap='round' stroke-linejoin='round' stroke-width='2' aria-hidden='true'>
    
    <path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37 0 0 0-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44 0 0 0 20 4.77 5.07 5.07 0 0 0 19.91 1S18.73.65 16 2.48a13.38 13.38 0 0 0-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07 0 0 0 5 4.77a5.44 5.44 0 0 0-1.5 3.78c0 5.42 3.3 6.61 6.44 7A3.37 3.37 0 0 0 9 18.13V22"/>
    
  </svg></i>
            </span>
          </a><a class="level-item" aria-label="email" href='mailto:yngpil.yoon@gmail.com'
            target='_blank' rel='noopener'>
            <span class="icon">
              <i class><svg viewbox='0 0 24 24' stroke-linecap='round' stroke-linejoin='round' stroke-width='2' aria-hidden='true'>
    
    <path d="M4 4h16c1.1 0 2 .9 2 2v12c0 1.1-.9 2-2 2H4c-1.1 0-2-.9-2-2V6c0-1.1.9-2 2-2z"/>
    <polyline points="22,6 12,13 2,6"/>
    
  </svg></i>
            </span>
          </a><a class="level-item" aria-label="instagram" href='https://instagram.com/ziwon.y'
            target='_blank' rel='noopener'>
            <span class="icon">
              <i class><svg viewbox='0 0 24 24' stroke-linecap='round' stroke-linejoin='round' stroke-width='2' aria-hidden='true'>
    
    <rect x="2" y="2" width="20" height="20" rx="5" ry="5"/>
    <path d="M16 11.37A4 4 0 1 1 12.63 8 4 4 0 0 1 16 11.37z"/>
    <line x1="17.5" y1="6.5" x2="17.5" y2="6.5"/>
    
  </svg></i>
            </span>
          </a></nav>
      </div>
    </nav>

    <nav class="nav">
      

      
    </nav>

  </div>
  <script src="/js/navicon-shift.js"></script>
</section>
<section class="section">
  <div class="container">
    <article>
      <h1 class="title"><a href="https://ziwon.github.io/post/tgik-004/">TGI Kubernetes 004: RBAC</a></h1>
      <h2 class="subtitle is-6">2019-02-05 </h2>
      <div class="subtitle tags is-6 is-pulled-right">
        
        
<a class="subtitle is-6" href="/tags/kubernetes">#Kubernetes</a>



  
  | <a class="subtitle is-6" href="/tags/rbac">#RBAC</a>
  

        
      </div>
      <div class="content">
        <p><a href="https://github.com/heptio/tgik/tree/master/episodes/004">네번째 에피소드</a>는 쿠버네티스의 RBAC을 중심으로 인증(Authorization)과 권한(Authentication)에 대해 설명하고 있다. 영상에서도 <a href="https://www.linkedin.com/pulse/adding-users-quick-start-kubernetes-aws-jakub-scholz">Adding users on &ldquo;Quick Start for Kubernetes on AWS&rdquo;</a> 블로그 내용을 참고해서 사용자 계정을 추가하고 있기 때문에, RBAC에 대해 충분한 이해가 있다면 해당 아티클만 보아도 좋을 듯 하다.  RBAC에 대한 기본적인 개념과 쿠버네티스에서의 RBAC 정책에 대해 좀 더 알고자 한다면 CNCF의 <a href="https://www.youtube.com/watch?v=CnHTCTP8d48">Role based access control (RBAC) policies in Kubernetes</a> 웨비나를 추천한다.</p>
<!-- raw HTML omitted -->
<h2 id="kubeconfig">KubeConfig</h2>
<p><code>kubeconfig</code> 파일의 기본 위치는 <code>$HOME/.kube/config</code>이며, <code>KUBECONFIG</code> 환경변수 또는 <code>--kubeconfig</code> 옵션으로 지정할 수 있다.</p>
<p>앞선 TGIK 데모에서는 Heptio의 QuickStart를 사용해 쿠버네티스 클러스터를 생성할 때, 클러스터 작업을 실행하기 위해 다음과 같은 방법으로 마스터 노드에서 복사한 <code>kubeconfig</code> 파일을 로컬에 복사하였다.</p>
<p>QuickStart에서 CloudFormation으로 프로비저닝할 때, 로컬 복사를 위한 커맨드가 다음과 같이 자동으로 생성되는데, 보다시피 <code>nc</code> 명령을 이용해 netcat 링크를 만들어 내부 마스터 서버에 접속하고 있다. (<code>netcat</code>을 이용하지 않고, <code>-W</code> 옵션으로도 클라이언트의 입출력을 마스터 호스트로 전달할 수 있다.)</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell"><span class="nv">SSH_KEY</span><span class="o">=</span><span class="s2">&#34;path/to/laptop.pem&#34;</span><span class="p">;</span> scp -i <span class="nv">$SSH_KEY</span> -o <span class="nv">ProxyCommand</span><span class="o">=</span><span class="s2">&#34;ssh -i \&#34;</span><span class="si">${</span><span class="nv">SSH_KEY</span><span class="si">}</span><span class="s2">\&#34; ubuntu@13.209.9.190 nc %h %p&#34;</span> ubuntu@10.0.21.21:~/kubeconfig ./kubeconfig
</code></pre></div><p>다음은 복사된 <code>kubeconfig</code> 파일의 내용이다.</p>
<div class="highlight"><pre class="chroma"><code class="language-yaml" data-lang="yaml"><span class="k">apiVersion</span><span class="p">:</span><span class="w"> </span>v1<span class="w">
</span><span class="w"></span><span class="k">clusters</span><span class="p">:</span><span class="w">
</span><span class="w"></span>- <span class="k">cluster</span><span class="p">:</span><span class="w">
</span><span class="w">    </span><span class="k">certificate-authority-data</span><span class="p">:</span><span class="w"> </span>&lt;base64-encoded-ca-cert<span class="sd">&gt;
</span><span class="sd">    server: https://13.125.59.233:6443</span><span class="w">
</span><span class="w">  </span><span class="k">name</span><span class="p">:</span><span class="w"> </span>kubernetes<span class="w">
</span><span class="w"></span><span class="k">contexts</span><span class="p">:</span><span class="w">
</span><span class="w"></span>- <span class="k">context</span><span class="p">:</span><span class="w">
</span><span class="w">    </span><span class="k">cluster</span><span class="p">:</span><span class="w"> </span>kubernetes<span class="w">
</span><span class="w">    </span><span class="k">user</span><span class="p">:</span><span class="w"> </span>admin<span class="w">
</span><span class="w">  </span><span class="k">name</span><span class="p">:</span><span class="w"> </span>admin@kubernetes<span class="w">
</span><span class="w"></span><span class="k">current-context</span><span class="p">:</span><span class="w"> </span>admin@kubernetes<span class="w">
</span><span class="w"></span><span class="k">kind</span><span class="p">:</span><span class="w"> </span>Config<span class="w">
</span><span class="w"></span><span class="k">preferences</span><span class="p">:</span><span class="w"> </span>{}<span class="w">
</span><span class="w"></span><span class="k">users</span><span class="p">:</span><span class="w">
</span><span class="w"></span>- <span class="k">name</span><span class="p">:</span><span class="w"> </span>admin<span class="w">
</span><span class="w">  </span><span class="k">user</span><span class="p">:</span><span class="w">
</span><span class="w">  	</span><span class="k">client-certificate-data</span><span class="p">:</span><span class="w"> </span>&lt;base64-encoded-csr<span class="sd">&gt;
</span><span class="sd">  	client-key-data: &lt;base64-encoded-private-key&gt;</span><span class="w">
</span></code></pre></div><p>보다시피, yaml 파일 형식이며, <code>certificate-authority-data</code>, <code>client-certificate-data</code>, <code>client-key-data</code>처럼 인증서 및 개인키는 base64로 인코딩되어 있다.</p>
<h3 id="certificate-authority-data">certificate-authority-data</h3>
<p>첫 번째 base64로 인코딩된 데이터는 API 서버의 TLS 인증서를 발급한 CA(certificate authority, 인증 기관)이다. 대부분의 TLS 연결은 기본적으로 <code>/etc/ssl</code>에서 신뢰하는 CA를 찾는데, 쿠버네티스의 경우 <code>kubeconfig</code> 파일의 <code>certificate-authority-data</code> 에 API 서버의 TLS 인증서를 발급한 Root CA을 기술하고 있다.</p>
<p>Root CA외에 API 서버에서 인자로 전달되는 인증서, 공개키, 개인키 데이터는 다음과 같다. (쿠버네티스 1.13.x 기준)</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">$ kube-apiserver 
    --authorization-mode<span class="o">=</span>Node,RBAC 
    --advertise-address<span class="o">=</span>172.17.0.3 
    --allow-privileged<span class="o">=</span><span class="nb">true</span> 
    --client-ca-file<span class="o">=</span>/etc/kubernetes/pki/ca.crt 
    --enable-admission-plugins<span class="o">=</span>NodeRestriction 
    --enable-bootstrap-token-auth<span class="o">=</span><span class="nb">true</span> 
    --etcd-cafile<span class="o">=</span>/etc/kubernetes/pki/etcd/ca.crt 
    --etcd-certfile<span class="o">=</span>/etc/kubernetes/pki/apiserver-etcd-client.crt 
    --etcd-keyfile<span class="o">=</span>/etc/kubernetes/pki/apiserver-etcd-client.key 
    --etcd-servers<span class="o">=</span>https://127.0.0.1:2379 
    --insecure-port<span class="o">=</span><span class="m">0</span> 
    --kubelet-client-certificate<span class="o">=</span>/etc/kubernetes/pki/apiserver-kubelet-client.crt 
    --kubelet-client-key<span class="o">=</span>/etc/kubernetes/pki/apiserver-kubelet-client.key 
    --kubelet-preferred-address-types<span class="o">=</span>InternalIP,ExternalIP,Hostname 
    --proxy-client-cert-file<span class="o">=</span>/etc/kubernetes/pki/front-proxy-client.crt 
    --proxy-client-key-file<span class="o">=</span>/etc/kubernetes/pki/front-proxy-client.key 
    --requestheader-allowed-names<span class="o">=</span>front-proxy-client 
    --requestheader-client-ca-file<span class="o">=</span>/etc/kubernetes/pki/front-proxy-ca.crt 
    --requestheader-extra-headers-prefix<span class="o">=</span>X-Remote-Extra- 
    --requestheader-group-headers<span class="o">=</span>X-Remote-Group 
    --requestheader-username-headers<span class="o">=</span>X-Remote-User 
    --secure-port<span class="o">=</span><span class="m">6443</span> 
    --service-account-key-file<span class="o">=</span>/etc/kubernetes/pki/sa.pub 
    --service-cluster-ip-range<span class="o">=</span>10.96.0.0/12 
    --tls-cert-file<span class="o">=</span>/etc/kubernetes/pki/apiserver.crt 
    --tls-private-key-file<span class="o">=</span>/etc/kubernetes/pki/apiserver.key
</code></pre></div><p>보다시피 API 서버의 경우, TLS 연결을 위한 인증서와 개인키는 각각 <code>--tls-cert-file</code>, <code>--tls-private-key-file</code> 인자를 통해 전달되고 있다. 그리고 API 서버의 <code>--client-ca-file</code> 인자는 <code>/etc/kubernetes/pki/ca.crt</code> 파일로 전달되고 있는데, 이는 쿠버네티스의 Root CA이며, 이는 앞서 살펴본 <code>kubeconfig</code>의 <code>certificate-authority-data</code>와 동일하다.</p>
<p>모든 쿠버네티스 클러스터에는 쿠버네티스 컨트롤 플레인 또는 사용자에게 인증서를 제공하는데 사용할 수 있는 클러스터 내장 인증 기관(certificate authority)이 있다. CA는 API 컴포넌트에서 API 서버의 인증서를 확인하고, API 서버가 kubelet 클라이언트 인증서를 확인하는데 사용한다. 이를 지원하기 위해 CA 인증서 번들은 클러스터의 모든 노드에 분산되며 <code>default</code> 서비스 계정에 연결된 시크릿으로서 배포된다. 쿠버네티스에는 기본적으로 세 가지 Root CA가 필요하다. 이들은 <code>/etc/kubernetes/pki</code>에 저장된다.</p>
<!-- raw HTML omitted -->
<table>
<thead>
<tr>
<th>path</th>
<th>CN</th>
<th>description</th>
</tr>
</thead>
<tbody>
<tr>
<td>ca.crt,key</td>
<td>kubernetes-ca</td>
<td>Kubernetes general CA</td>
</tr>
<tr>
<td>etcd/ca.crt,key</td>
<td>etcd-ca</td>
<td>For all etcd-related function</td>
</tr>
<tr>
<td>front-proxy-ca.crt,key</td>
<td>kubernetes-front-proxy-ca</td>
<td>For the front-end proxy</td>
</tr>
</tbody>
</table>
<p>(참고 - <a href="https://kubernetes.io/docs/setup/certificates/">PKI Certificates and Requirements</a>)</p>
<!-- raw HTML omitted -->
<p>이외에도 API 서버는 다음과 같이 인증과 관련된 다른 커맨드라인 인자를 지정할 수 있다. (참고 - <a href="https://kubernetes.io/docs/reference/command-line-tools-reference/kube-apiserver/">kube-apiserver
</a>)</p>
<div class="highlight"><pre class="chroma"><code class="language-txt" data-lang="txt">--cert-dir string                           The directory where the TLS certs are located. If --tls-cert-file and --tls-private-key-file are provided, this flag will be ignored. (default &#34;/var/run/kubernetes&#34;)
--client-ca-file string                     If set, any request presenting a client certificate signed by one of the authorities in the client-ca-file is authenticated with an identity corresponding to the CommonName of the client certificate.
--etcd-certfile string                      SSL certification file used to secure etcd communication.
--etcd-keyfile string                       SSL key file used to secure etcd communication.
--etcd-cafile string                        SSL Certificate Authority file used to secure etcd communication.
--kubelet-certificate-authority string      Path to a cert file for the certificate authority.
--kubelet-client-certificate string         Path to a client cert file for TLS.
--kubelet-client-key string                 Path to a client key file for TLS.
--proxy-client-cert-file string             Client certificate used to prove the identity of the aggregator or kube-apiserver when it must call out during a request. This includes proxying requests to a user api-server and calling out to webhook admission plugins. It is expected that this cert includes a signature from the CA in the --requestheader-client-ca-file flag. That CA is published in the &#39;extension-apiserver-authentication&#39; configmap in the kube-system namespace. Components recieving calls from kube-aggregator should use that CA to perform their half of the mutual TLS verification.
--proxy-client-key-file string              Private key for the client certificate used to prove the identity of the aggregator or kube-apiserver when it must call out during a request. This includes proxying requests to a user api-server and calling out to webhook admission plugins.
--requestheader-allowed-names stringSlice   List of client certificate common names to allow to provide usernames in headers specified by --requestheader-username-headers. If empty, any client certificate validated by the authorities in --requestheader-client-ca-file is allowed.
--requestheader-client-ca-file string       Root certificate bundle to use to verify client certificates on incoming requests before trusting usernames in headers specified by --requestheader-username-headers
--service-account-key-file stringArray      File containing PEM-encoded x509 RSA or ECDSA private or public keys, used to verify ServiceAccount tokens. If unspecified, --tls-private-key-file is used. The specified file can contain multiple keys, and the flag can be specified multiple times with different files.
--ssh-keyfile string                        If non-empty, use secure SSH proxy to the nodes, using this user keyfile
--tls-ca-file string                        If set, this certificate authority will used for secure access from Admission Controllers. This must be a valid PEM-encoded CA bundle. Alternatively, the certificate authority can be appended to the certificate provided by --tls-cert-file.
--tls-cert-file string                      File containing the default x509 Certificate for HTTPS. (CA cert, if any, concatenated after server cert). If HTTPS serving is enabled, and --tls-cert-file and --tls-private-key-file are not provided, a self-signed certificate and key are generated for the public address and saved to /var/run/kubernetes.
--tls-private-key-file string               File containing the default x509 private key matching --tls-cert-file.
--tls-sni-cert-key namedCertKey             A pair of x509 certificate and private key file paths, optionally suffixed with a list of domain patterns which are fully qualified domain names, possibly with prefixed wildcard segments. If no domain patterns are provided, the names of the certificate are extracted. Non-wildcard matches trump over wildcard matches, explicit domain patterns trump over extracted names. For multiple key/certificate pairs, use the --tls-sni-cert-key multiple times. Examples: &#34;example.crt,example.key&#34; or &#34;foo.crt,foo.key:*.foo.com,foo.com&#34;. (default [])
</code></pre></div><p>다음과 같이, <code>kubectl</code>에서 클러스터 노드 정보를 조회할 때 디버그 레벨 <code>--v=10</code>을 지정해보자.</p>
<!-- raw HTML omitted -->
<p>그러면 위 상세 로그에서 다음과 같은 <code>kubectl get node</code>에 대응하는 <code>curl</code> 명령어를 확인할 수 있다.</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">$ curl -k -v -XGET  -H <span class="s2">&#34;Accept: application/json;as=Table;v=v1beta1;g=meta.k8s.io, application/json&#34;</span> -H <span class="s2">&#34;User-Agent: kubectl/v1.12.3 (darwin/amd64) kubernetes/435f92c&#34;</span> <span class="s1">&#39;https://13.125.59.233:6443/api/v1/nodes?limit=500&#39;</span>
</code></pre></div><p>위 <code>kubectl</code>을 통해서 호출되는 API 서버의 응답은 다음과 같다.</p>
<!-- raw HTML omitted -->
<p>위 <code>curl</code> 명령을 <code>kubeconfig</code>에 인증서없이 그대로 호출하게 되면, 다음과 같이 API 서버로부터 <code>403</code> 인증 오류가 반환된다.</p>
<div class="highlight"><pre class="chroma"><code class="language-json" data-lang="json"><span class="p">{</span>
  <span class="nt">&#34;kind&#34;</span><span class="p">:</span> <span class="s2">&#34;Status&#34;</span><span class="p">,</span>
  <span class="nt">&#34;apiVersion&#34;</span><span class="p">:</span> <span class="s2">&#34;v1&#34;</span><span class="p">,</span>
  <span class="nt">&#34;metadata&#34;</span><span class="p">:</span> <span class="p">{},</span>
  <span class="nt">&#34;status&#34;</span><span class="p">:</span> <span class="s2">&#34;Failure&#34;</span><span class="p">,</span>
  <span class="nt">&#34;message&#34;</span><span class="p">:</span> <span class="s2">&#34;nodes is forbidden: User \&#34;system:anonymous\&#34; cannot list nodes at the cluster scope&#34;</span><span class="p">,</span>
  <span class="nt">&#34;reason&#34;</span><span class="p">:</span> <span class="s2">&#34;Forbidden&#34;</span><span class="p">,</span>
  <span class="nt">&#34;details&#34;</span><span class="p">:</span> <span class="p">{</span>
    <span class="nt">&#34;kind&#34;</span><span class="p">:</span> <span class="s2">&#34;nodes&#34;</span>
  <span class="p">},</span>
  <span class="nt">&#34;code&#34;</span><span class="p">:</span> <span class="mi">403</span>
<span class="p">}</span>
</code></pre></div><h3 id="client-certificate-data-client-key-data">client-certificate-data, client-key-data</h3>
<p>쿠버네티스는 서버와 클라이언트가 각각 상호 인증(mutual authentication)한다.</p>
<p>만약, <code>kubeconfig</code> 파일의 <code>certificate-authority-data</code>에 데이터가 잘못되거나 값이 삭제될 경우에는 다음과 같이 서버 연결이 사이닝되지 않았다는 오류를 볼 수 있다.</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">$ kubectl get node
Unable to connect to the server: x509: certificate signed by unknown authority
</code></pre></div><p>API 서버에 대해 보안 연결이 맺어져도 클라이언트 인증이 되어야 제한된 리소스에 접근이 가능하다. 이 때 클라이언트 인증시에 필요한 CSR과 프라이빗 키의 데이터가 각각 <code>client-certificate-data</code>, <code>client-key-data</code>에 기록된다.</p>
<h2 id="인증-authentication">인증 (Authentication)</h2>
<p>쿠버네티스 클라이언트 컴포넌트가 API 서버에 연결을 맺을 때, 쿠버네티스가 사용자 ID를 할당하는 여러 가지 방법이 있을 수 있는데, 쿠버네티스에는 다음과 같은 인증 방법이 있다. (참고 - <a href="https://kubernetes.io/docs/reference/access-authn-authz/authentication/#authentication-strategies">Authentication strategies</a>)</p>
<ul>
<li>X509 Client Certs: 괜찮은 인증 방법이지만, 정기적으로 클라이언트 인증서 갱신 및 재배포를 처리해야 한다.</li>
<li>Static Token File: 일시적이지 않은 특성 때문에 추천하지 않는다.</li>
<li>Bootstrap Tokens: 위의 정적 토큰과 동일하다.</li>
<li>Static Password File: API 서버를 재시작하지 않으면 패스워드를 변경할 수 없기 때문에 추천하지 않는다.</li>
<li>Service Account Tokens: 최종 사용자가 쿠버네티스 클러스터와 상호 작용하려는 경우 사용해서는 안되나, 쿠버네티스에서 실행되는 응용 프로그램 및 작업 부하에 대해서는 추천할 수 있는 인증 방법이다.</li>
<li>OpenID Connect Tokens: OIDC가 AWS IAM 등 ID 제공 업체와 통합되므로 최종 사용자를 위한 최상의 인증 방법이다.</li>
<li>Webhook Token Authentication: OIDC와 마찬가지로 Webhook으로 GitHub 개인 토큰을 통합하여 최종 사용자가 사용할 수 있는 인증 방법이다.</li>
<li>Authentication Proxy: <code>X-Remote-User</code>와 같은 요청 헤더의 값을 설정하는 인증 프락시와 통합시에 사용하는 인증 방법이다.</li>
</ul>
<p>클라이언트 인증서를 생성하는 방법은 다음과 같다. (참고 - <a href="https://kubernetes.io/docs/tasks/tls/managing-tls-in-a-cluster/">Manage TLS Certificates in a Cluster</a>)</p>
<p>영상에서는 클라이언트 인증을 위한 임의의 사용자 계정(예, <code>users:ziwon</code>)을 추가하는 예제를 보이고 있다.</p>
<p>먼저 개인키를 생성한다.</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">$ openssl genrsa -out ziwon.pem <span class="m">2048</span>
</code></pre></div><p>다음으로 인증서 발급에 필요한 CSR(Certificate Signing Request, 인증서 서명 요청)을 생성한다.</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">$ openssl req -new -key ziwon.pem -out ziwon.csr -subj <span class="s2">&#34;/CN=users:ziwon/O=cloud-native&#34;</span>
</code></pre></div><p>그리고 생성된 CSR을 쿠버테스트에 등록하기 위해 base64로 인코딩한 값을 추출한다.</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">$ cat ziwon.csr <span class="p">|</span> base64 <span class="p">|</span> tr -d <span class="s1">&#39;\n&#39;</span>
</code></pre></div><p>생성된 쿠버네티스 csr을 등록한다.</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">$ cat <span class="s">&lt;&lt; EOF | kubectl apply -f -
</span><span class="s">apiVersion: certificates.k8s.io/v1beta1
</span><span class="s">kind: CertificateSigningRequest
</span><span class="s">metadata:
</span><span class="s">  name: user-request-ziwon
</span><span class="s">spec:
</span><span class="s">  groups:
</span><span class="s">  - system:authenticated
</span><span class="s">  request: &lt;base64-encoded-csr&gt;
</span><span class="s">  usages:
</span><span class="s">  - digital signature
</span><span class="s">  - key encipherment
</span><span class="s">  - client auth
</span><span class="s">EOF</span>
</code></pre></div><p>등록 후, <code>pending</code> 상태에 있는 <code>user-request-ziwon</code>의 값을 승인한다.</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">$ kubectl certificate approve user-request-ziwon
</code></pre></div><p>승인된 <code>user-request-ziwon</code> CSR로부터 공개키를 생성한다.</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">$ kubectl get csr user-request-ziwon -o <span class="nv">jsonpath</span><span class="o">=</span><span class="s1">&#39;{.status.certificate}&#39;</span> <span class="p">|</span> base64 -d &gt; ziwon.crt
</code></pre></div><p>쿠버네티스 API 서버의 Root CA, 그리고 클라이언트의 공개키와 개인키를 이용해, 클라이언트 <code>kubeconfig</code> 파일을 생성한다.</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">$ cat ziwon.crt <span class="p">|</span> base64 <span class="p">|</span> tr -d <span class="s1">&#39;\n&#39;</span>
</code></pre></div><div class="highlight"><pre class="chroma"><code class="language-yaml" data-lang="yaml"><span class="k">apiVersion</span><span class="p">:</span><span class="w"> </span>v1<span class="w">
</span><span class="w"></span><span class="k">clusters</span><span class="p">:</span><span class="w">
</span><span class="w"></span>- <span class="k">cluster</span><span class="p">:</span><span class="w">
</span><span class="w">    </span><span class="k">certificate-authority-data</span><span class="p">:</span><span class="w"> </span>&lt;base64-encoded-ca-cert<span class="sd">&gt;
</span><span class="sd">    server: https://localhost:53079</span><span class="w">
</span><span class="w">  </span><span class="k">name</span><span class="p">:</span><span class="w"> </span>kubernetes<span class="w">
</span><span class="w"></span><span class="k">contexts</span><span class="p">:</span><span class="w">
</span><span class="w"></span>- <span class="k">context</span><span class="p">:</span><span class="w">
</span><span class="w">    </span><span class="k">cluster</span><span class="p">:</span><span class="w"> </span>kubernetes<span class="w">
</span><span class="w">    </span><span class="k">user</span><span class="p">:</span><span class="w"> </span>ziwon<span class="w">
</span><span class="w">  </span><span class="k">name</span><span class="p">:</span><span class="w"> </span>ziwon@kubernetes<span class="w">
</span><span class="w"></span><span class="k">current-context</span><span class="p">:</span><span class="w"> </span>ziwon@kubernetes<span class="w">
</span><span class="w"></span><span class="k">kind</span><span class="p">:</span><span class="w"> </span>Config<span class="w">
</span><span class="w"></span><span class="k">preferences</span><span class="p">:</span><span class="w"> </span>{}<span class="w">
</span><span class="w"></span><span class="k">users</span><span class="p">:</span><span class="w">
</span><span class="w"></span>- <span class="k">name</span><span class="p">:</span><span class="w"> </span>ziwon<span class="w">
</span><span class="w">  </span><span class="k">user</span><span class="p">:</span><span class="w">
</span><span class="w">    </span><span class="k">client-certificate-data</span><span class="p">:</span><span class="w"> </span>&lt;base64-encoded-crt<span class="sd">&gt;
</span><span class="sd">    client-key-data: &lt;base64-encoded-key-data&gt;</span><span class="w">
</span></code></pre></div><p>그러면 다음과 같이 API 서버에 대해 클라이언트 ID <code>users:ziwon</code> 로 접근이 되는 것을 볼 수 있다. 그러나 접근이 되더라도 권한(Authoriztion)을 부여받은 Role이 지정되지 않았다. 따라서, 클러스터 리소스 및 네임스페이스 리소스 접근시 각각 오류 응답을 받게 된다.</p>
<ul>
<li>클러스터 객체 접근시</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">$ kubectl get node
Error from server <span class="o">(</span>Forbidden<span class="o">)</span>: nodes is forbidden: User <span class="s2">&#34;users:ziwon&#34;</span> cannot list resource <span class="s2">&#34;nodes&#34;</span> in API group <span class="s2">&#34;&#34;</span> at the cluster scope
</code></pre></div><ul>
<li>네임스페이스 객체 접근시</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">$ kubectl get pod
Error from server <span class="o">(</span>Forbidden<span class="o">)</span>: pods is forbidden: User <span class="s2">&#34;users:ziwon&#34;</span> cannot list resource <span class="s2">&#34;pods&#34;</span> in API group <span class="s2">&#34;&#34;</span> in the namespace <span class="s2">&#34;default&#34;</span>
</code></pre></div><h2 id="권한-authorization">권한 (Authorization)</h2>
<p>모든 쿠버네티스트 리소스는 다음과 같이 클러스터 객체와 네임스페이스 객체로 구분할 수 있다.</p>
<h3 id="클러스터-객체">클러스터 객체</h3>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">$ kubectl api-resources --namespaced<span class="o">=</span><span class="nb">false</span>
NAME                              SHORTNAMES   APIGROUP                       NAMESPACED   KIND
componentstatuses                 cs                                          <span class="nb">false</span>        ComponentStatus
namespaces                        ns                                          <span class="nb">false</span>        Namespace
nodes                             no                                          <span class="nb">false</span>        Node
persistentvolumes                 pv                                          <span class="nb">false</span>        PersistentVolume
mutatingwebhookconfigurations                  admissionregistration.k8s.io   <span class="nb">false</span>        MutatingWebhookConfiguration
validatingwebhookconfigurations                admissionregistration.k8s.io   <span class="nb">false</span>        ValidatingWebhookConfiguration
customresourcedefinitions         crd,crds     apiextensions.k8s.io           <span class="nb">false</span>        CustomResourceDefinition
apiservices                                    apiregistration.k8s.io         <span class="nb">false</span>        APIService
tokenreviews                                   authentication.k8s.io          <span class="nb">false</span>        TokenReview
selfsubjectaccessreviews                       authorization.k8s.io           <span class="nb">false</span>        SelfSubjectAccessReview
selfsubjectrulesreviews                        authorization.k8s.io           <span class="nb">false</span>        SelfSubjectRulesReview
subjectaccessreviews                           authorization.k8s.io           <span class="nb">false</span>        SubjectAccessReview
certificatesigningrequests        csr          certificates.k8s.io            <span class="nb">false</span>        CertificateSigningRequest
podsecuritypolicies               psp          extensions                     <span class="nb">false</span>        PodSecurityPolicy
podsecuritypolicies               psp          policy                         <span class="nb">false</span>        PodSecurityPolicy
clusterrolebindings                            rbac.authorization.k8s.io      <span class="nb">false</span>        ClusterRoleBinding
clusterroles                                   rbac.authorization.k8s.io      <span class="nb">false</span>        ClusterRole
priorityclasses                   pc           scheduling.k8s.io              <span class="nb">false</span>        PriorityClass
storageclasses                    sc           storage.k8s.io                 <span class="nb">false</span>        StorageClass
volumeattachments                              storage.k8s.io                 <span class="nb">false</span>        VolumeAttachment
</code></pre></div><h3 id="네임스페이스-객체">네임스페이스 객체</h3>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">$ kubectl api-resources --namespaced
NAME                        SHORTNAMES   APIGROUP                    NAMESPACED   KIND
bindings                                                             <span class="nb">true</span>         Binding
configmaps                  cm                                       <span class="nb">true</span>         ConfigMap
endpoints                   ep                                       <span class="nb">true</span>         Endpoints
events                      ev                                       <span class="nb">true</span>         Event
limitranges                 limits                                   <span class="nb">true</span>         LimitRange
persistentvolumeclaims      pvc                                      <span class="nb">true</span>         PersistentVolumeClaim
pods                        po                                       <span class="nb">true</span>         Pod
podtemplates                                                         <span class="nb">true</span>         PodTemplate
replicationcontrollers      rc                                       <span class="nb">true</span>         ReplicationController
resourcequotas              quota                                    <span class="nb">true</span>         ResourceQuota
secrets                                                              <span class="nb">true</span>         Secret
serviceaccounts             sa                                       <span class="nb">true</span>         ServiceAccount
services                    svc                                      <span class="nb">true</span>         Service
controllerrevisions                      apps                        <span class="nb">true</span>         ControllerRevision
daemonsets                  ds           apps                        <span class="nb">true</span>         DaemonSet
deployments                 deploy       apps                        <span class="nb">true</span>         Deployment
replicasets                 rs           apps                        <span class="nb">true</span>         ReplicaSet
statefulsets                sts          apps                        <span class="nb">true</span>         StatefulSet
localsubjectaccessreviews                authorization.k8s.io        <span class="nb">true</span>         LocalSubjectAccessReview
horizontalpodautoscalers    hpa          autoscaling                 <span class="nb">true</span>         HorizontalPodAutoscaler
cronjobs                    cj           batch                       <span class="nb">true</span>         CronJob
<span class="nb">jobs</span>                                     batch                       <span class="nb">true</span>         Job
leases                                   coordination.k8s.io         <span class="nb">true</span>         Lease
events                      ev           events.k8s.io               <span class="nb">true</span>         Event
daemonsets                  ds           extensions                  <span class="nb">true</span>         DaemonSet
deployments                 deploy       extensions                  <span class="nb">true</span>         Deployment
ingresses                   ing          extensions                  <span class="nb">true</span>         Ingress
networkpolicies             netpol       extensions                  <span class="nb">true</span>         NetworkPolicy
replicasets                 rs           extensions                  <span class="nb">true</span>         ReplicaSet
networkpolicies             netpol       networking.k8s.io           <span class="nb">true</span>         NetworkPolicy
poddisruptionbudgets        pdb          policy                      <span class="nb">true</span>         PodDisruptionBudget
rolebindings                             rbac.authorization.k8s.io   <span class="nb">true</span>         RoleBinding
roles                                    rbac.authorization.k8s.io   <span class="nb">true</span>         Role
</code></pre></div><p>다음과 같이 RBAC에 의한 리소스 접근시에 권한과 관련된 네임스페이스 객체와 클러스터 객체가 있다.</p>
<h3 id="네임스페이스-role--rolebinding">네임스페이스 Role &amp; RoleBinding</h3>
<ul>
<li>Role</li>
<li>RoleBinding</li>
</ul>
<p>쿠버네티스의 네임스페이스에 정의된 기본적인 <code>role</code> 목록은 다음과 같다.</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">$ kubectl get role --all-namespaces
NAMESPACE     NAME                                             AGE
kube-public   kubeadm:bootstrap-signer-clusterinfo             8h
kube-public   system:controller:bootstrap-signer               8h
kube-system   extension-apiserver-authentication-reader        8h
kube-system   kube-proxy                                       8h
kube-system   kubeadm:kubelet-config-1.13                      8h
kube-system   kubeadm:nodes-kubeadm-config                     8h
kube-system   system::leader-locking-kube-controller-manager   8h
kube-system   system::leader-locking-kube-scheduler            8h
kube-system   system:controller:bootstrap-signer               8h
kube-system   system:controller:cloud-provider                 8h
kube-system   system:controller:token-cleaner                  8h
kube-system   weave-net                                        8h
</code></pre></div><h3 id="클러스터-role--rolebinding">클러스터 Role &amp; RoleBinding</h3>
<ul>
<li>ClusterRole</li>
<li>ClusterRoleBinding</li>
</ul>
<p>쿠버네티스의 클러스터에 정의된 기본적인 <code>clusterrole</code> 목록은 다음과 같다.</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">$ kubectl get clusterrole
NAME                                                                   AGE
admin                                                                  8h
cluster-admin                                                          8h
edit                                                                   8h
system:aggregate-to-admin                                              8h
system:aggregate-to-edit                                               8h
system:aggregate-to-view                                               8h
system:auth-delegator                                                  8h
system:aws-cloud-provider                                              8h
system:basic-user                                                      8h
system:certificates.k8s.io:certificatesigningrequests:nodeclient       8h
system:certificates.k8s.io:certificatesigningrequests:selfnodeclient   8h
system:controller:attachdetach-controller                              8h
system:controller:certificate-controller                               8h
system:controller:clusterrole-aggregation-controller                   8h
system:controller:cronjob-controller                                   8h
system:controller:daemon-set-controller                                8h
system:controller:deployment-controller                                8h
system:controller:disruption-controller                                8h
system:controller:endpoint-controller                                  8h
system:controller:expand-controller                                    8h
system:controller:generic-garbage-collector                            8h
system:controller:horizontal-pod-autoscaler                            8h
system:controller:job-controller                                       8h
system:controller:namespace-controller                                 8h
system:controller:node-controller                                      8h
system:controller:persistent-volume-binder                             8h
system:controller:pod-garbage-collector                                8h
system:controller:pv-protection-controller                             8h
system:controller:pvc-protection-controller                            8h
system:controller:replicaset-controller                                8h
system:controller:replication-controller                               8h
system:controller:resourcequota-controller                             8h
system:controller:route-controller                                     8h
system:controller:service-account-controller                           8h
system:controller:service-controller                                   8h
system:controller:statefulset-controller                               8h
system:controller:ttl-controller                                       8h
system:coredns                                                         8h
system:csi-external-attacher                                           8h
system:csi-external-provisioner                                        8h
system:discovery                                                       8h
system:heapster                                                        8h
system:kube-aggregator                                                 8h
system:kube-controller-manager                                         8h
system:kube-dns                                                        8h
system:kube-scheduler                                                  8h
system:kubelet-api-admin                                               8h
system:node                                                            8h
system:node-bootstrapper                                               8h
system:node-problem-detector                                           8h
system:node-proxier                                                    8h
system:persistent-volume-provisioner                                   8h
system:volume-scheduler                                                8h
view                                                                   8h
weave-net                                                              8h
</code></pre></div><p>먼저, 클러스터 전체에 대해 정의된 기본 사용자 <code>system:basic-user</code>의 RBAC을 확인해보자.</p>
<!-- raw HTML omitted -->
<p>다음으로 클러스터 전체를 관리하는 관리자 <code>admin</code>의 RBAC을 확인해보자.</p>
<!-- raw HTML omitted -->
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">$ kubectl create rolebinding ziwon --clusterrole<span class="o">=</span>admin --user<span class="o">=</span>users:ziwon --dry-run -o yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: RoleBinding
metadata:
  creationTimestamp: null
  name: ziwon
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
  name: admin
subjects:
- apiGroup: rbac.authorization.k8s.io
  kind: User
  name: users:ziwon
</code></pre></div><!-- raw HTML omitted -->
<p>먼저, <code>foo</code>라는 네임스페이스를 만든다. 이때 기본 <code>~/.kube/config</code>를 사용한다.</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">$ kubectl run --restart<span class="o">=</span>Never --image<span class="o">=</span>gcr.io/kuar-demo/kuard-amd64:blue kuard
</code></pre></div><p>그리고 새로운 쉘에서 새로 추가된 사용자 <code>users:ziwon</code>의 <code>kubeconfig-ziwon</code>를 이용해 Pod을 하나 배포해본다.</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">$ <span class="nb">export</span> <span class="nv">KUBECONFIG</span><span class="o">=</span>/path/to/kubeconfig-ziwon
$ kubectl config set-context <span class="k">$(</span>kubectl config current-context<span class="k">)</span> --namespace<span class="o">=</span>foo
$ kubectl run --restart<span class="o">=</span>Never --image<span class="o">=</span>gcr.io/kuar-demo/kuard-amd64:blue kuard

Error from server <span class="o">(</span>Forbidden<span class="o">)</span>: pods is forbidden: User <span class="s2">&#34;users:ziwon&#34;</span> cannot create resource <span class="s2">&#34;pods&#34;</span> in API group <span class="s2">&#34;&#34;</span> in the namespace <span class="s2">&#34;foo&#34;</span>
</code></pre></div><p>배포가 되지 않는 것을 확인할 수 있다. 이에, 다시 어드민 계정으로 사용자 <code>users:ziwon</code>에 대한 <code>Pod</code> 등의 네임스페이스 객체 접근을 위한 <code>rolebinding</code>과 클러스터 객체 접근을 위한 <code>clusterrolebinding</code>을 만든다.</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">$ <span class="nb">export</span> <span class="nv">KUBECONFIG</span><span class="o">=</span>~/.kube/config
$ kubectl create rolebinding ziwon-role --clusterrole<span class="o">=</span>admin --user<span class="o">=</span>users:ziwon
$ kubectl create clusterrolebinding ziwon-clusterrole --clusterrole<span class="o">=</span>view --user<span class="o">=</span>users:ziwon
</code></pre></div><p>그러면 다음과 같이 정상적으로 배포가 되고, 네임스페이스 Pod 객체 목록을 정상적으로 확인할 수 있다.</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">$ kubectl run --restart<span class="o">=</span>Never --image<span class="o">=</span>gcr.io/kuar-demo/kuard-amd64:blue kuard
$ kubectl get pod -n foo
NAME    READY   STATUS    RESTARTS   AGE
kuard   1/1     Running   <span class="m">0</span>          17s
</code></pre></div><p>또한 다음과 같이, <code>clusterrolebinding</code>이 부여되었기 때문에 클러스터 전체 Pod 목록도 확인할 수 있다.</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">$ kubectl get pod --all-namespaces
NAMESPACE     NAME                                            READY   STATUS    RESTARTS   AGE
default       kuard                                           1/1     Running   <span class="m">0</span>          10m
foo           kuard                                           1/1     Running   <span class="m">0</span>          2m14s
kube-system   coredns-86c58d9df4-98rkf                        1/1     Running   <span class="m">0</span>          9h
kube-system   coredns-86c58d9df4-zt4l8                        1/1     Running   <span class="m">0</span>          9h
kube-system   etcd-kind-1-control-plane1                      1/1     Running   <span class="m">0</span>          9h
kube-system   etcd-kind-1-control-plane2                      1/1     Running   <span class="m">0</span>          9h
kube-system   kube-apiserver-kind-1-control-plane1            1/1     Running   <span class="m">0</span>          9h
kube-system   kube-apiserver-kind-1-control-plane2            1/1     Running   <span class="m">0</span>          9h
kube-system   kube-controller-manager-kind-1-control-plane1   1/1     Running   <span class="m">1</span>          9h
kube-system   kube-controller-manager-kind-1-control-plane2   1/1     Running   <span class="m">0</span>          9h
kube-system   kube-proxy-6cmkr                                1/1     Running   <span class="m">0</span>          9h
kube-system   kube-proxy-bzbwk                                1/1     Running   <span class="m">0</span>          9h
kube-system   kube-proxy-hlq4l                                1/1     Running   <span class="m">0</span>          9h
kube-system   kube-proxy-jl9sg                                1/1     Running   <span class="m">0</span>          9h
kube-system   kube-proxy-mw2rt                                1/1     Running   <span class="m">0</span>          9h
kube-system   kube-proxy-p9pzv                                1/1     Running   <span class="m">0</span>          9h
kube-system   kube-proxy-tjs8r                                1/1     Running   <span class="m">0</span>          9h
kube-system   kube-proxy-tvgz7                                1/1     Running   <span class="m">0</span>          9h
kube-system   kube-scheduler-kind-1-control-plane1            1/1     Running   <span class="m">1</span>          9h
kube-system   kube-scheduler-kind-1-control-plane2            1/1     Running   <span class="m">0</span>          9h
kube-system   weave-net-52l8x                                 2/2     Running   <span class="m">0</span>          9h
kube-system   weave-net-5f4lb                                 2/2     Running   <span class="m">0</span>          9h
kube-system   weave-net-6d9dx                                 2/2     Running   <span class="m">0</span>          9h
kube-system   weave-net-6nhns                                 2/2     Running   <span class="m">1</span>          9h
kube-system   weave-net-6t7tw                                 2/2     Running   <span class="m">0</span>          9h
kube-system   weave-net-hqlw6                                 2/2     Running   <span class="m">0</span>          9h
kube-system   weave-net-m2dn4                                 2/2     Running   <span class="m">0</span>          9h
kube-system   weave-net-nrsvs                                 2/2     Running   <span class="m">0</span>          9h
</code></pre></div><h2 id="service-account">Service Account</h2>
<p>다음과 같이 모든 네임스페이스에는 기본적으로 <code>default</code> 서비스 계정이 존재한다. 쿠버네티스에 RBAC이 있기 전에 클러스터에 접근하는 방법이 Service Account였기 때문이다.</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">$ kubectl get sa --all-namespaces
NAMESPACE     NAME                                 SECRETS   AGE
default       default                              <span class="m">1</span>         2d1h
foo           default                              <span class="m">1</span>         39h
kube-public   default                              <span class="m">1</span>         2d1h
kube-system   default                              <span class="m">1</span>         2d1h
...
</code></pre></div><p>즉, 어플리케이션을 실행시키고 싶으면, 일종의 봇 아이텐티티를 지닌 어플리케이션 고유의 개별 서비스 계정을 주어서 클러스터의 다른 리소스들과 통신하게 할 수 있었다. 그러나 RBAC이 추가되고 베스트 프랙티스로써 알려지게 되면서 문제가 되는 것이, RBAC 측면에서 기존의 <code>default</code> 계정은 zero 인증과 권한을 가지게 된다는 것이다. 그 대표적인 예가 helm이다. 설치한 후에 RBAC 인증으로 인해 제대로 동작하지 않아 다음과 같은 서비스 계정을 만들고 RBAC 정책을 설정해주어야 한다.</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">kubectl create serviceaccount --namespace kube-system tiller
kubectl create clusterrolebinding tiller-cluster-rule --clusterrole<span class="o">=</span>cluster-admin --serviceaccount<span class="o">=</span>kube-system:tiller
kubectl patch deploy --namespace kube-system tiller-deploy -p <span class="s1">&#39;{&#34;spec&#34;:{&#34;template&#34;:{&#34;spec&#34;:{&#34;serviceAccount&#34;:&#34;tiller&#34;}}}}&#39;</span>
helm init --service-account tiller --upgrade
</code></pre></div><p>그래서 기존의 <code>default</code> 서비스 계정 등 서비스 계정에 관한 RBAC 정책이 이슈가 될 수 있는데, 다음 문서는 서비스 계정에 대한 [Heptio사의 RBAC 베스트 프랙티스](<a href="http://docs.heptio.com/content/tutorials/rbac.html">How to: RBAC best practices and workarounds</a>)에서는 개별 서비스 계정을 만들어 권한을 부여하는 것을 좀 더 안전한 프랙티스로 권하고 있다.</p>
<h2 id="관련-링크">관련 링크</h2>
<ul>
<li><a href="https://rsec.kr/?p=426">RSA 인증서 (Certification) 와 전자서명 (Digital Sign)의 원리</a></li>
<li><a href="https://kubernetes.io/docs/reference/access-authn-authz/rbac/">Using RBAC Authorization</a></li>
<li><a href="https://www.linkedin.com/pulse/adding-users-quick-start-kubernetes-aws-jakub-scholz">Adding users on &ldquo;Quick Start for Kubernetes on AWS&rdquo;</a></li>
<li><a href="http://docs.heptio.com/content/tutorials/rbac.html">How to: RBAC best practices and workarounds</a></li>
<li><a href="https://jvns.ca/blog/2017/08/05/how-kubernetes-certificates-work/">How Kubernetes certificate authorities work</a></li>
<li><a href="https://dev.to/petermbenjamin/kubernetes-security-best-practices-hlk#authentication">Kubernetes Security Best-Practices</a></li>
</ul>

        
        <div class="related">

<h3>Similar articles:</h3>
<ul>
	
	<li><a href="/post/tgik-003/">TGI Kubernetes 003: Istio</a></li>
	
	<li><a href="/post/tgik-002/">TGI Kubernetes 002: Networking and Services</a></li>
	
	<li><a href="/post/tgik-001/">TGI Kubernetes 001: A Quick Tour</a></li>
	
	<li><a href="/post/bastion-in-kops/">Kops에서 Bastion 호스트 SSH로 접속하기</a></li>
	
</ul>
</div>
        
      </div>
    </article>
    

    
    <nav class="post-nav">
        
        <a class="prev" href="https://ziwon.github.io/post/tgik-005/">
            &lt; <span class="prev-text nav-default">TGI Kubernetes 005: Pod Params and Probes</span>
                <span class="prev-text nav-mobile"></span>
        </a>
        
        <a class="next" href="https://ziwon.github.io/post/tgik-003/">
            <span class="next-text nav-default">TGI Kubernetes 003: Istio</span>
            <span class="next-text nav-mobile"></span>
            >
        </a>
    </nav>

  </div>
 
</section>

<section class="section">
  <div class="container">
    <aside><div id="disqus_thread"></div></aside>
  
    <script type="text/javascript">
      var disqus_shortname = 'ziwon';
      function disqus() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
      }
  
      disqus();
  

    </script>
    <noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript>
  </div>
</section>


<section class="section">
  <div class="container has-text-centered">
    <p><a href="https://github.com/ziwon">Yeongpil Yoon</a></p>
    
      <p>Powered by <a href="https://gohugo.io/">Hugo</a> &amp; <a href="https://github.com/ribice/kiss">Kiss</a>.</p>
    
  </div>
</section>


<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'UA-129419926-1', 'auto');
	
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>




</body>
</html>

